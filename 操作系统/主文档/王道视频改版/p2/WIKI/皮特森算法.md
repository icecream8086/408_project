# 皮特森算法

## 1. 完整定义

**皮特森算法**（Peterson's Algorithm）是一种用于解决两个进程/线程间互斥访问共享资源的软件算法，确保不会同时进入临界区。其核心是通过两个共享变量 `flag`（表示进程的进入意愿）和 `turn`（表示轮次）来实现的。

算法伪代码如下（以进程 `P0` 和 `P1` 为例）：

```python
# 共享变量
flag = [False, False]  # 表示进程是否想进入临界区
turn = 0  # 表示当前轮到谁

# 进程 Pi (i = 0 或 1)
def enter_critical_section(i):
    j = 1 - i  # 另一个进程的编号
    flag[i] = True  # 表示自己想进入
    turn = j     # 礼貌地让对方先走
    while flag[j] and turn == j:  # 如果对方也想进且轮次是对方，则等待
        pass

# 临界区代码...

def exit_critical_section(i):
    flag[i] = False  # 表示自己已退出
```

### 2. 通俗语言描述

皮特森算法就像两个人（进程）通过“谦让”来轮流使用一个房间（临界区）。

- 每个人先举手（`flag[i]=True`）表示自己想用房间，然后客气地说“你先请”（`turn=j`）。
- 如果对方也举着手（`flag[j]=True`）且当前轮次是对方（`turn==j`），自己就等待；否则就进入房间。
- 用完后放下手（`flag[i]=False`），让对方有机会进入。

### 3. 通俗比喻

想象两个小朋友（小红和小蓝）想玩同一个玩具：

1. 小红先举手说：“我想玩，但小蓝你可以先玩。”（`flag[红]=True`, `turn=蓝`）
2. 如果小蓝也想玩（`flag[蓝]=True`）且小红说了“小蓝先玩”（`turn==蓝`），小红就乖乖等着。
3. 否则小红直接玩玩具。
4. 玩完后，小红放下手（`flag[红]=False`），小蓝就可以玩了。

这样既不会抢玩具，也不会饿死（总有人能玩到）。

### 4. 主体与其它部分分解

**主体部分**：

- **互斥逻辑**：通过 `flag` 和 `turn` 的组合判断，确保只有一个进程能进入临界区。
  - 公式：进程 `i` 等待的条件是 `flag[j] && turn == j`（对方想进且轮次是对方）。
- **谦让机制**：`turn=j` 强制进程“让一次”，避免死锁。

**其它部分**：

- **共享变量**：`flag` 和 `turn` 必须对所有进程可见（通常是全局变量）。
- **局限性**：仅适用于两个进程，多进程需要更复杂的算法（如面包店算法）。

### 对照组（皮特森算法 vs 简单锁）

| 特性     | 皮特森算法         | 简单锁（如 `test-and-set`） |
| -------- | ------------------ | --------------------------- |
| 实现方式 | 纯软件             | 需要硬件支持                |
| 进程数   | 仅支持两个         | 支持多个                    |
| 公平性   | 严格轮流（无饥饿） | 可能饥饿                    |
| 忙等     | 是（自旋等待）     | 是                          |

---

## 可以理解成 01 两种状态，每个进程各持有一个状态代表自己，进程检查共享变量是否为 01 来决定是否是自己进入吗 ?

你的理解**部分正确**，但需要更精确的表述。皮特森算法的核心确实是利用共享变量 `flag` 和 `turn` 的“状态组合”来协调进程，但它的逻辑比简单的“01 状态轮流检查”更巧妙。下面分点澄清：

---

### 1. **你的类比 vs 实际算法**

- **你的理解**：  
  “两个进程各自持有一个状态（类似 01），通过检查共享变量决定谁进入。”  
  **接近，但不完全对**。皮特森算法的 `flag` 和 `turn` 是**组合判断**，不是简单的轮流 01。

- **实际逻辑**：  
  每个进程的进入条件取决于：
  - 对方是否想进（`flag[j] == True`）
  - **且**当前轮次是否是对方的（`turn == j`）  
    只有这两个条件**同时满足**时，自己才等待，否则进入临界区。

---

### 2. **为什么不是简单的“01 轮流”？**

- 如果只用 `turn`（01 轮流），可能会这样：

  ```python
  while turn != i: pass  # 简单轮流
  ```

  **问题**：若进程 `P1` 不想进入临界区，`P0` 仍然要傻等 `turn` 轮到自己，效率低。

- **皮特森算法的改进**：  
  通过 `flag` + `turn` 双重判断：
  - `flag`：进程**主动声明**自己想进（不是被动轮流）。
  - `turn`：解决“同时举手”的冲突（公平性）。

---

### 3. **通俗修正版比喻**

想象两人过独木桥：

1. **举手（`flag`）**：
   - 你要过桥时，必须举手（`flag[i]=True`）。
2. **让路（`turn`）**：
   - 你同时指向对方说“你先过”（`turn=j`），表示礼貌谦让。
3. **是否等待**：
   - 如果对方**也举着手**（`flag[j]==True`）**且**你刚才说了“你先过”（`turn==j`），你就等待。
   - 否则（对方没举手，或轮次是你），直接过桥。

**关键**：只有两人**同时想进**时，才靠 `turn` 决定谁先过（避免死锁）。

---

### 4. **公式化条件**

进程 `i` 进入临界区的条件是：  
`!(flag[j] && turn == j)`  
（即：对方不想进，**或**虽然对方想进但轮次不是对方。）

---

### 5. **与“01 状态轮流”的对比**

| 特性       | 皮特森算法                 | 你假设的“01 轮流”          |
| ---------- | -------------------------- | -------------------------- |
| 协调变量   | `flag[2]` + `turn`         | 仅 `turn`（01）            |
| 进程主动性 | 进程主动声明意图（`flag`） | 被动等待轮次               |
| 效率       | 对方不想进时可直接进入     | 必须严格轮流，即使对方空闲 |
| 解决冲突   | 双重判断（防同时进入）     | 无冲突处理，可能死锁       |

---

### 总结

可以理解为**“01 状态+”**：

- `flag` 是进程的**主动声明**（类似举手），
- `turn` 是**冲突时的仲裁器**（类似猜拳）。  
  两者结合，既避免忙等浪费，又保证互斥和公平。

---

## 进程是先修改 flag，然后修改 turn，然后两进程如果 flag 都为 true 就通过 turn 申请，选一个执行?

你的直觉是对的！如果两个进程**先全部修改 `flag`，再抢 `turn`**，确实会导致**“后来者先进入”**的现象，这就是皮特森算法的一个关键设计点——**通过 `turn` 的谦让机制避免“抢跑”**。下面详细解释：

---

### 1. **如果先全改 `flag`，再抢 `turn` 会发生什么？**

假设两个进程 `P0` 和 `P1` 按以下顺序执行：

1. `P0` 设置 `flag[0] = True`
2. `P1` 设置 `flag[1] = True`
3. `P0` 设置 `turn = 1`
4. `P1` 设置 `turn = 0`

此时：

- `flag = [True, True]`
- `turn` 的值**取决于最后一步**（`P1` 后执行，所以 `turn = 0`）。

**检查条件**：

- `P0` 看到 `flag[1] == True` 且 `turn == 0`（自己），所以 `P0` 进入临界区。
- `P1` 看到 `flag[0] == True` 且 `turn == 0`（不是自己），所以 `P1` 等待。

**结果**：后修改 `turn` 的 `P1` 反而被阻塞，`P0` 先进入——这就是“**后来者让先到者**”（后修改 `turn` 的进程礼让）。

---

### 2. **为什么皮特森算法要这样设计？**

- **避免“抢跑”**：  
  如果两个进程同时竞争，`turn` 的**最后写入者会礼让**，确保先执行到 `turn=j` 的进程能优先进入。
  - 这是一种“**谦让式仲裁**”，类似“谁先谦让，谁就先获得权限”。
- **保证公平性**：  
  由于 `turn` 会在后续轮次中交换，长期来看两个进程都能进入（无饥饿）。

---

### 3. **对比“先抢 `turn` 再改 `flag`”的错误方案**

如果交换顺序（先抢 `turn`，再改 `flag`）：

```python
turn = j          # 先抢 turn
flag[i] = True    # 再改 flag
```

**问题**：

- `P0` 设置 `turn=1`，但还未设置 `flag[0]=True`。
- `P1` 此时看到 `turn=1` 且 `flag[0]==False`，直接进入临界区。
- 接着 `P0` 设置 `flag[0]=True`，但 `P1` 已经在临界区了 → **互斥失败！**

→ 因此，**必须先改 `flag`，再抢 `turn`**。

---

### 4. **用交通信号灯类比**

- **`flag` 是红灯**：表示“我想用资源”（亮红灯阻止他人）。
- **`turn` 是谦让规则**：
  - 你先亮红灯（`flag[i]=True`），然后设置“让对方先走”（`turn=j`）。
  - 如果对方也亮了红灯（`flag[j]=True`），则检查 `turn`：
    - 如果你设置了“让对方先走”（`turn == j`），你就等待；
    - 否则（`turn == i`），说明对方更礼貌，对方在等你，于是你进入。

**关键**：**最后设置 `turn` 的人会礼让**，因此先执行到 `turn=j` 的进程会优先获得权限。

---

### 5. **总结**

- **皮特森算法的 `turn` 不是“抢夺”，而是“谦让”**：
  - 最后设置 `turn` 的进程会主动让行，因此**先修改 `turn` 的进程会先进入**。
- **这种设计保证了**：
  1. **互斥**：不会同时进入临界区。
  2. **无饥饿**：竞争时轮流进入。
  3. **无死锁**：至少有一个进程能进入。

**一句话**：  
“先举手（`flag`）表明意图，再礼貌让权（`turn`），最后检查对方是否更需要——后来者反而会礼让先到者。”
