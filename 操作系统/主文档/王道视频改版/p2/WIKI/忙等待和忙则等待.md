
# **关于“忙等待”与“忙则等待”的关系**

## **1. 定义对比**

| **术语**     | 全称/定义                                                                      | 简称/俗称        | 应用场景                      |
| ------------ | ------------------------------------------------------------------------------ | ---------------- | ----------------------------- |
| **忙等待**   | **Busy Waiting**：通过循环不断检查条件（消耗 CPU 资源）                        | 无简称，直接使用 | 自旋锁、TS/CAS 操作           |
| **忙则等待** | **“空闲让进，忙则等待”**：同步机制的设计原则之一（来自 Dijkstra 的临界区准则） | 原则描述，非简称 | 任何互斥锁（如信号量、Mutex） |

## **2. 关键区别**

- **忙等待（Busy Waiting）**：

  - **具体实现技术**：线程通过循环（如 `while(lock == true);`）持续占用 CPU，直到条件满足。
  - **问题**：浪费 CPU 周期，适用于短期等待（如内核自旋锁）。

- **忙则等待（No Busy, No Entry）**：
  - **设计原则**：当临界区被占用时，新线程必须等待（但不限定如何等待——可以是阻塞、睡眠或忙等待）。
  - **目标**：保证互斥性，属于高层逻辑规范。

## **3. 为什么不能划等号？**

- **忙等待是“忙则等待”的一种实现方式**，但并非唯一方式：
  - 忙等待 → 自旋锁（`spinlock`）
  - 非忙等待 → 阻塞锁（`mutex`）、信号量（`semaphore`）
- **反例**：
  - 如果用 `mutex` 实现“忙则等待”，线程会休眠（不消耗 CPU），此时无忙等待。

## **4. 代码示例**

**忙等待实现（自旋锁）**：

```c
while (test_and_set(&lock) {}  // 忙等待：持续检查lock
/* 临界区 */
lock = false;
```

**非忙等待实现（阻塞锁）**：

```c
pthread_mutex_lock(&mutex);  // 忙则等待：线程休眠，不占CPU
/* 临界区 */
pthread_mutex_unlock(&mutex);
```

## **5. 类比解释**

- **忙等待**：  
  像在餐厅门口不断问“有空位吗？”（消耗自己精力，但反应快）。
- **忙则等待**：  
  餐厅规则“没位就等”（你可以选择站着等/登记后去逛街）。
- **忙等待 ≠ 忙则等待**，如同“反复打电话问结果” ≠ “被告知需要等待”。

## **6. 总结**

- **忙等待**是**一种具体的等待策略**（消耗 CPU）。
- **忙则等待**是**同步机制的设计原则**（不限定如何等待）。
- 在操作系统和并发编程中，二者需明确区分，避免混淆。

**一句话答案**：  
“忙等待是技术实现，忙则等待是设计原则——前者是后者的‘暴力版’，但后者不一定是前者。”
