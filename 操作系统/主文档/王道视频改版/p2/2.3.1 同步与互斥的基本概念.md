# [进程管理] 进程同步与互斥

## 摘要

通过生产者-消费者问题阐述同步互斥核心机制，结合 Linux futex 实现分析现代 OS 解决方案。提供 C/Python 代码案例及 perf 锁竞争分析方法。

## 主题

解决并发进程对共享资源的访问冲突，建立临界区保护机制与进程协作规范。核心挑战：在保证安全性的前提下平衡性能。

> 重点难点
>
> - 临界区访问的原子性保障（硬件/软件方案对比）
> - 信号量机制的正确实现与使用范式
> - 现代同步原语（如 Linux futex）的实现原理

## 线索区

### [临界区资源](./WIKI/Critical_Section.md)

### [临界区资源访问过程详解](./WIKI/Critical_Section.md)

### 知识点 1: 同步互斥基础

**工作机制**：

- **直接制约**（同步）：进程执行顺序约束（如管道读写需交替进行）
- **间接制约**（互斥）：`共享资源排他性访问`**（如打印机使用）**

**系统调用**：

```c
// POSIX线程互斥锁
pthread_mutex_lock(&mutex);
// 临界区操作
pthread_mutex_unlock(&mutex);
```

**Linux 命令**：

```bash
strace -e trace=futex ./program  # 跟踪快速用户态互斥锁调用
```

---

### 知识点 2: 临界区保护原则

**四要素实现代码**（Peterson 算法示例）：

```c
// 全局变量声明
int flag[2] = {0, 0};
int turn = 0;

// 进程i的进入区代码
flag[i] = 1;
turn = j;
while (flag[j] && turn == j);

// 退出区代码
flag[i] = 0;
```

**时间-空间权衡**：

- 软件方案（如 Dekker 算法）：O(1)时间但需要原子指令
- 硬件方案（TSL 指令）：依赖 CPU 特性但实现更简洁

---

### 知识点 3: 现代同步机制

**Linux futex 原理**：

```python
# Python线程同步示例
import threading
lock = threading.Lock()

with lock:  # 自动管理进入/退出区
    # 临界区操作
    pass
```

**性能参数**：

- 用户态无竞争操作耗时：**<100ns**
- 内核态唤醒延迟：**1-10μs**（取决于调度策略）

---

## 总结区

| 考点             | 典型题型                     | 分析工具           |
| ---------------- | ---------------------------- | ------------------ |
| 互斥算法缺陷分析 | 给出代码判断是否满足四原则   | perf lock 分析争用 |
| 同步机制选择依据 | 对比信号量/管程/RCU 适用场景 | futexgraph 可视化  |
| 死锁预防         | 银行家算法资源分配模拟       | lockdep 静态检测   |

**实验脚本**（Linux 5.4+）：

```bash
#!/bin/bash
# 监测锁竞争
perf lock record -p $(pidof your_program)
perf lock report --threads
```
