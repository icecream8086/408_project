# **操作系统的四个基本特征**

## **摘要**

本部分详细解析了操作系统的四个基本特征：**并发**、**共享**、**虚拟**和**异步**。这些特征是操作系统设计和实现的核心基础，理解它们对于掌握操作系统的原理至关重要。

---

## **主题**

1. **并发与共享**

   - 并发和共享是操作系统最基本的特征，二者互为存在条件。
   - 没有并发就没有共享，反之亦然。

2. **虚拟性**

   - 通过虚拟技术（如虚拟存储器和虚拟处理器）将物理资源映射为多个逻辑资源，提高资源利用率。

3. **异步性**
   - 多道程序并发执行时，进程的执行速度不可预知，走走停停，这是资源有限和进程争抢资源的结果。

---

### **重点难点**

- **并发与并行的区别**
- **互斥共享与同时共享的区别**
- **虚拟技术的分类与应用**
- **异步性的原因与表现**

---

### **知识点详解**

#### **知识点 1：并发与并行**

- **并发**

  - 定义：多个事件在同一时间间隔内发生，宏观上同时，微观上交替。
  - 示例：老渣交替进行两个约会任务。
  - 特点：通过时间片轮转实现多个任务的“同时”执行。

- **并行**

  - 定义：多个事件在同一时刻同时发生。
  - 示例：小渣同时进行两个约会任务。
  - 特点：需要多核或多处理器支持。

- **对比**
  - 并发是逻辑上的同时，并行是物理上的同时。

---

#### **知识点 2：共享性**

- **互斥共享**

  - 定义：资源在同一时间段内只允许一个进程使用。
  - 示例：QQ 和微信视频聊天时，摄像头只能被一个进程使用。
  - 特点：通过锁机制实现资源的独占访问。

- **同时共享**
  - 定义：资源在同一时间段内允许多个进程访问。
  - 示例：QQ 和微信同时发送文件，宏观上同时，微观上交替访问硬盘。
  - 特点：通过分时复用技术实现资源的共享。

---

#### **知识点 3：虚拟性**

- **虚拟存储器**

  - 定义：将物理内存和磁盘空间结合，扩展可用内存空间。
  - 示例：4G 内存的电脑可以同时运行多个需要超过 4G 内存的应用程序。
  - 特点：通过页面置换算法（如 LRU）管理内存和磁盘之间的数据交换。

- **虚拟处理器**
  - 定义：通过时间片轮转技术，使单核 CPU 模拟多核 CPU 的效果。
  - 示例：单核 CPU 通过虚拟处理器技术，使得用户感觉有多个 CPU 在同时服务。
  - 特点：通过调度算法（如 CFS）实现多任务的公平执行。

---

#### **知识点 4：异步性**

- **定义**

  - 多道程序并发执行时，进程的执行速度不可预知，走走停停。
  - 原因：资源有限，进程争抢资源导致执行顺序不确定。

- **表现**
  - 进程的执行时间不可预测，可能因为等待 I/O 或资源而被挂起。
  - 示例：多个进程同时请求 CPU 时间片，执行顺序由调度器决定。

### 单/多 道操作系统

#### **单道操作系统**

> 定义

单道操作系统是指一次只允许一个程序在内存中运行的操作系统。当一个程序运行时，其他程序必须等待该程序执行完毕才能开始运行。

特点

简单性：系统结构简单，易于实现和管理。

资源利用率低：CPU 和 I/O 设备的利用率较低，因为当一个程序等待 I/O 操作时，CPU 会空闲。

无并发性：一次只能运行一个程序，无法实现多任务并发执行。

- 示例

早期的批处理系统，如 IBM 的 OS/360。

#### **多道操作系统**

> 定义

多道操作系统是指允许多个程序同时在内存中运行的操作系统。通过时间片轮转和调度算法，系统可以在多个程序之间快速切换，实现并发执行。

特点

高资源利用率：CPU 和 I/O 设备的利用率较高，因为当一个程序等待 I/O 操作时，CPU 可以切换到其他程序执行。

在多道操作系统中，程序 A 和 B 可以并发执行。假设 CPU 可以在程序 A 等待 I/O 时切换到程序 B

> 关键点

- CPU 不会空闲等待：只要系统中存在就绪的程序，CPU 就会切换到这些程序运行，而不是空闲等待。

- I/O 操作是异步的：I/O 操作由专门的 I/O 设备处理，CPU 不需要等待 I/O 完成。

- 调度算法的角色：操作系统通过调度算法决定哪个程序在何时占用 CPU，以实现高效的资源利用。

#### **现代计算机并发模型的扩展**

现代计算机并发模型在多道操作系统的基础上，引入了更多的技术和机制，以应对更复杂的计算需求：

#### （1）**多线程与多进程**

- **多线程**：一个程序可以分成多个线程，每个线程可以独立执行。线程之间共享内存空间，通信成本低。
- **多进程**：多个程序（进程）可以同时运行，每个进程有独立的内存空间，通过进程间通信（IPC）机制交换数据。
- **现代操作系统**（如 Windows、Linux、macOS）都支持多线程和多进程，允许更细粒度的并发执行。

#### （2）**多核与并行计算**

- 现代 CPU 通常是多核的，每个核心可以独立执行一个线程或进程。
- 操作系统和编程语言（如 Java、Python、C++）提供了对多核并行的支持，允许程序充分利用硬件资源。
- 并行计算框架（如 OpenMP、MPI）进一步扩展了并发模型，支持大规模并行任务。

#### （3）**异步 I/O 和非阻塞操作**

- 现代操作系统支持异步 I/O 操作，程序可以在发起 I/O 请求后继续执行其他任务，而不需要阻塞等待 I/O 完成。
- 编程模型（如 Node.js 的异步 I/O、Python 的 asyncio）利用这一特性，实现高效的并发处理。

#### （4）**虚拟化与容器化**

- 虚拟化技术（如 VMware、KVM）和容器化技术（如 Docker、Kubernetes）允许多个操作系统实例或应用程序在同一硬件上并发运行。
- 这些技术进一步提高了资源利用率和系统灵活性。

#### （5）**分布式计算**

- 现代并发模型不仅限于单机，还扩展到分布式系统。多个计算机通过网络协作，共同完成计算任务。
- 分布式计算框架（如 Hadoop、Spark）和微服务架构（如 Kubernetes）是这一领域的典型代表。

---

### 3. **现代并发模型与多道操作系统的关系**

- **继承**：现代并发模型继承了多道操作系统的核心思想，即通过资源共享和任务切换实现并发执行。
- **扩展**：现代并发模型在多道操作系统的基础上，引入了多线程、多核并行、异步 I/O、虚拟化和分布式计算等新技术，以应对更复杂的计算需求。
- **优化**：现代操作系统和编程语言对并发模型进行了大量优化，例如更高效的调度算法、锁机制、无锁数据结构等，以提高并发性能和可靠性。

---

#### **现代并发模型与多道操作系统的关系**

。现代并发模型通过多线程、多核并行、异步 I/O、虚拟化和分布式计算等技术，实现了更高效、更灵活的并发和并行计算能力。多道操作系统是现代并发模型的**基石**，而现代并发模型则是其**进化和发展**。

---

## **总结**

1. **并发与共享**

   - 并发和共享是操作系统最基本的特征，二者互为存在条件。
   - 没有并发就没有共享，反之亦然。

2. **虚拟性**

   - 通过虚拟技术将物理资源映射为多个逻辑资源，提高资源利用率。

3. **异步性**

   - 多道程序并发执行时，进程的执行速度不可预知，走走停停，这是资源有限和进程争抢资源的结果。

4. **考试重点**
   - 并发与并行的区别
   - 互斥共享与同时共享的区别
   - 虚拟技术的分类与应用
   - 异步性的原因与表现
   - 多通道耗时计算(包含甘特图绘制)

---

### **实验与代码示例**

#### **并发示例（Python）**

```python
import threading

def task(name):
    print(f"Task {name} is running")

threads = []
for i in range(5):
    t = threading.Thread(target=task, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

#### **互斥共享示例（C）**

```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t lock;

void* task(void* arg) {
    pthread_mutex_lock(&lock);
    printf("Thread %d is using the resource\n", *(int*)arg);
    pthread_mutex_unlock(&lock);
    return NULL;
}

int main() {
    pthread_t threads[5];
    int ids[5] = {1, 2, 3, 4, 5};
    pthread_mutex_init(&lock, NULL);

    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, task, &ids[i]);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&lock);
    return 0;
}
```
