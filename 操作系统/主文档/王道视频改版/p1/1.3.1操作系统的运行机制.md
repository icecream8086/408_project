# CPU 状态切换与操作系统运行机制

## 摘要

本笔记详细解析了操作系统运行机制中的核心概念，重点围绕**CPU 状态切换**、**特权指令与非特权指令的区别**以及**操作系统内核的功能**展开。通过机制图解、代码示例和 Linux 命令演示，帮助理解操作系统如何管理硬件资源并执行程序。

---

## 主题

核心内容聚焦于：

- **CPU 状态切换**：内核态与用户态的切换机制及其硬件支持。
- **特权指令与非特权指令**：内核程序与应用程序的执行权限差异。
- **操作系统内核功能**：系统资源的管理者，执行特权指令。
- **程序运行机制**：从高级语言到机器指令的转换与执行。

> 重点难点
>
> - **CPU 状态切换的硬件机制**：理解 PSW（Program Status Word）标志位的修改过程。
> - **特权指令与非特权指令的权限控制**：内核态与用户态的权限边界。
> - **操作系统内核的核心功能**：资源管理与程序执行的底层实现。

---

## 线索区

### 知识点 1：CPU 状态切换的过程

- **开机初始化**：
  - 加载操作系统，CPU 处于**内核态**，执行内核程序。
  - 操作系统完成硬件初始化与资源分配。
- **用户程序执行**：
  - 用户启动应用程序，CPU 从**内核态**切换到**用户态**。
  - 应用程序执行**非特权指令**，无法直接访问硬件资源。
- **特权指令与中断**：
  - 内核程序通过**特权指令**修改 PSW 标志位，完成状态切换。
  - 应用程序尝试执行特权指令会触发**中断信号**，CPU 强行切换至**内核态**。

#### 代码示例：状态切换的硬件支持

```c
// 伪代码：修改PSW标志位
void switch_to_kernel_mode() {
    asm volatile ("mov %0, %%cr0" : : "r"(PSW_KERNEL_MODE));
}

void switch_to_user_mode() {
    asm volatile ("mov %0, %%cr0" : : "r"(PSW_USER_MODE));
}
```

#### Linux 命令示例：查看 CPU 状态

```bash
# 查看当前进程的CPU状态（用户态/内核态）
ps -eo pid,comm,state
```

---

### 知识点 2：特权指令与非特权指令

- **特权指令**：
  - 仅在内核态下执行，可能影响系统资源或其他程序。
  - 示例：修改 PSW、直接访问硬件设备。
- **非特权指令**：
  - 在用户态下执行，仅影响当前程序。
  - 示例：算术运算、逻辑判断。

#### 对比示意图

| **特性**     | **特权指令**       | **非特权指令**       |
| ------------ | ------------------ | -------------------- |
| **执行权限** | 内核态             | 用户态               |
| **影响范围** | 系统全局           | 当前程序             |
| **示例**     | 修改 PSW、I/O 操作 | 加法、减法、跳转指令 |

---

### 知识点 3：操作系统内核功能

- **系统资源管理**：
  - 操作系统内核是硬件资源的管理者，负责分配 CPU、内存、I/O 设备等资源。
- **内核程序**：
  - 由操作系统开发者编写，执行特权指令，组成操作系统内核。
- **容器技术**：
  - 如 Docker，仅依赖 Linux 内核即可运行，无需完整操作系统。

#### 现实类比：内核态与用户态

- **内核态**：如同机场控制塔，拥有最高权限，管理所有航班（进程）的起降。
- **用户态**：如同航班，只能在指定跑道（资源）上运行，无法直接干预其他航班。

---

## 总结区

本笔记系统梳理了操作系统运行机制的核心概念，重点包括：

1. **CPU 状态切换**：通过 PSW 标志位实现内核态与用户态的切换。
2. **特权指令与非特权指令**：内核态下执行特权指令，用户态下执行非特权指令。
3. **操作系统内核功能**：管理硬件资源，执行特权指令，支持应用程序运行。

**考点与重点**：

- CPU 状态切换的硬件机制（PSW 标志位）。
- 特权指令与非特权指令的执行权限差异。
- 操作系统内核的核心功能与实现。

**难点**：

- 理解 CPU 状态切换的硬件支持（如 PSW 修改）。
- 区分特权指令与非特权指令的实际应用场景。

**实验建议**：

- 使用`strace`工具跟踪系统调用，观察 CPU 状态切换：

  ```bash
  strace -c ls
  ```

- 编写 C 程序模拟特权指令执行，观察中断触发：

  ```c
  #include <stdio.h>
  int main() {
      asm volatile ("mov %0, %%cr0" : : "r"(0x80000000)); // 尝试修改PSW
      return 0;
  }
  ```
