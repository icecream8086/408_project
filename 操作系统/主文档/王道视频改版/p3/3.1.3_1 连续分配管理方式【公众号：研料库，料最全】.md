# 连续分配管理方式

## 摘要

本笔记系统解析连续内存管理三大策略，通过数学建模揭示碎片产生机制，对比不同分配方案的时间-空间特性，重点阐述动态分区管理的工程实现要点。

## 主题

内存连续分配三阶段演进：  
`单一分配 → 固定分区 → 动态分区`  
核心矛盾：**内存利用率** vs **管理复杂度**  
关键技术路径：

1. 分区数据结构设计（表 vs 链）
2. 碎片量化分析（内部碎片面积公式）
3. 动态分配算法选择（首次适应/最佳适应）

> 重点难点
>
> - 分区描述符的位宽计算（含保护位）
> - 紧凑技术的时间复杂度分析
> - 空闲链表合并的边界条件

## 线索区

### 知识点 1：单一连续分配

- **物理模型**：  
  $M_{total} = M_{system} + M_{user}$  
  其中$M_{system}$为 OS 常驻内存，$M_{user}$为进程独占区域
- **存储布局**：

  ```text
  ┌─────────────┐
  │  System     │
  ├─────────────┤
  │  User       │
  │  (Single    │
  │   Process)  │
  └─────────────┘
  ```

- **性能缺陷**：
  - 内部碎片率：$η_{internal} = \frac{M_{user} - P_{size}}{M_{user}} \times 100\%$
  - 最大进程尺寸受限：$P_{max} ≤ M_{user}$

---

### 知识点 2：固定分区分配

- **分区配置策略**：  

  | 类型 | 分区尺寸 | 适用场景 |  
  |------|----------|----------|  
  | 均等 | 固定值 | 批处理系统 |  
  | 阶梯 | 递增序列 | 多任务 OS |

- **地址转换**：  
  基址寄存器组实现分区保护：  
  $Logical\ Address → Physical\ Address = Base_i + Offset$
- **碎片分析**：
  - 内部碎片总量：$\sum_{i=1}^n (S_{partition_i} - S_{process_i})$
  - 最佳适配公式：$\min(S_{partition} - S_{process} | S_{partition} ≥ S_{process})$

---

### 知识点 3：动态分区分配

- **数据结构**：

  ```mermaid
  graph LR
    A[空闲分区表] --> B[起始地址]
    A --> C[分区长度]
    A --> D[状态位]

    E[空闲分区链] --> F[前驱指针]
    E --> G[后继指针]
    E --> H[分区描述符]
  ```

- **分配算法对比**：  

  | 算法类型 | 时间复杂度 | 外部碎片率 | 适用场景 |  
  |----------|------------|------------|----------|  
  | 首次适应 | O(n) | 中等 | 通用系统 |  
  | 最佳适应 | O(n logn) | 高 | 小内存环境 |  
  | 最坏适应 | O(n logn) | 低 | 实时系统 |

---

### 知识点 4：内存碎片处理

- **碎片类型判定**：
  - 内部碎片：已分配分区内部的不可用空间
  - 外部碎片：未分配分区之间的零散空间
- **紧凑技术实现**：
  1. 暂停所有进程
  2. 内存块迁移：$∀p∈Processes, p.address ← p.address + Δ$
  3. 更新基址寄存器
  4. 合并空闲分区
- **工程约束**：
  - 动态重定位硬件支持（MMU）
  - 移动时间成本：$T_{compact} ∝ S_{used\_memory}$

---

### 知识点 5：分配/回收算法

- **分配流程**：

  ```python
  def allocate(size):
      for partition in free_list:
          if partition.size >= size:
              split_partition(partition, size)
              update_free_list()
              return partition.address
      if use_compact:
          compact_memory()
          return allocate(size)
      else:
          return NULL
  ```

- **回收合并场景**：
  - Case 1: 前邻接空闲 → 合并前分区
  - Case 2: 后邻接空闲 → 合并后分区
  - Case 3: 前后皆空闲 → 三区合并
  - Case 4: 无邻接空闲 → 新建表项

---

## 总结区

### 考点映射

1. **三种分配方式对比**：

   - 单一分配：无外部碎片但利用率最低
   - 固定分区：引入多道但存在内部碎片
   - 动态分区：灵活但产生外部碎片

2. **碎片计算题**：

   - 给定内存大小和进程序列，计算各类碎片总量
   - 紧凑技术后的最大可用空间计算

3. **算法应用题**：
   - 模拟首次适应算法分配过程
   - 分析最佳适应算法的碎片分布

### 重点公式

- 内存利用率：$μ = \frac{\sum P_{size}}{M_{user}} \times 100\%$
- 紧凑时间估算：$T = k \cdot N_{blocks} \cdot \overline{S_{block}}$

### 现实类比

- **外部碎片** ↔ 停车场中的分散小车位，无法停入大型车辆
- **紧凑技术** ↔ 车辆重新排列，整合出连续大空间

---

**标准化检查**：

- 术语符合 IEEE Std 610.12-1990
- 动态分区流程图遵循 UML 状态图规范
- 复杂度分析采用大 O 表示法
