# 进程内存映像与存储管理

## 摘要

本笔记系统化梳理 32 位系统中进程内存布局，通过分层解析用户区与内核区结构，阐明全局变量、堆区、共享库等关键区域的存储特性与管理机制，为理解操作系统内存管理提供结构化认知框架。

## 主题

32 位系统虚拟内存空间分配与数据存储策略  
**核心方法**：地址空间分区管理 + 动态内存分配机制  
**关键词**：虚拟地址空间、PCB、页表、malloc/free、共享库映射  
**问题提示**：堆栈增长方向如何影响内存分配？共享库映射如何实现多进程复用？

> 重点难点
>
> - 虚拟地址到物理地址的转换机制
> - 堆区动态扩展与内存碎片管理
> - 用户栈帧结构与函数调用链的关联

---

## 线索区

### 1. 32 位系统内存架构

**定义**：

- **虚拟地址空间**：$2^{32}$ = 4GB 线性空间（0x00000000 ~ 0xFFFFFFFF）
- **内核区**：高地址**1GB**固定区域（存储 PCB、页表等核心数据）
- **用户区**：低地址 3GB 可编程空间，含代码段/数据段/堆栈等

**原理图示**：

```text
0xFFFFFFFF ┌────────────┐
           │  内核区    │
0xC0000000 ├────────────┤
           │  用户栈    │ ← 动态向下扩展
           ├────────────┤
           │ 共享库映射 │ ← 动态大小
           ├────────────┤
           │    堆区    │ ← 动态向上扩展
           ├────────────┤
           │ 全局/静态变量 │ ← 固定大小
           ├────────────┤
           │  只读数据  │
0x08048000 ├────────────┤
           │  代码段    │
0x00000000 └────────────┘
```

**典型应用**：

- 进程创建时内核建立页表映射
- 用户程序通过 brk/sbrk 系统调用管理堆空间

---

### 2. 关键数据区域特性

| 区域类型       | 存储内容            | 生命周期   | 管理方式  | 最大容量限制               |
| -------------- | ------------------- | ---------- | --------- | -------------------------- |
| **代码段**     | 机器指令            | 进程全程   | 只读      | 受 ELF 文件大小限制        |
| **数据段**     | 全局变量/静态变量   | 进程全程   | 读写      | 编译时确定                 |
| **堆区**       | malloc 动态分配内存 | 显式释放   | 动态增长  | 用户区剩余空间-栈大小      |
| **共享库映射** | libc.so 等共享对象  | 按需加载   | mmap 映射 | 受物理内存限制             |
| **用户栈**     | 局部变量/函数调用帧 | 函数作用域 | 自动管理  | ulimit -s 设置（默认 8MB） |

**技术参数**：

- **典型栈帧结构**：

  ```c
  | 参数n    | ← esp+12
  | ...      |
  | 参数1    | ← esp+4
  | 返回地址  | ← esp
  | 旧ebp    | ← ebp
  | 局部变量1 |
  | ...      | ← ebp-4
  ```

---

### 3. 动态内存管理机制

**堆区扩展**：

- 通过 brk 指针调整堆顶位置
- malloc 分配策略：
  - **首次适应**：遍历空闲链表寻找首个足够块
  - **最佳适应**：选择最小合适空闲块
  - **碎片处理**：通过内存合并(coalescing)减少外部碎片

**栈动态特性**：

- 函数调用时压入参数/返回地址/局部变量
- **栈溢出检测**：通过 Guard Page 机制触发 SIGSEGV
- 典型问题：递归深度过大导致**栈耗尽**（Stack Overflow）

---

## 总结区

### 知识关联

1. **内存保护**：通过 MMU 实现用户/内核模式隔离（CR0 寄存器控制）
2. **性能权衡**：
   - 堆分配灵活但易产生碎片
   - 栈分配高效但有大小限制
3. **考点聚焦**：
   - 虚拟地址空间布局图绘制
   - malloc/free 实现原理（隐式空闲链表）
   - 栈帧结构与函数调用过程解析

### 难点突破

- **堆栈碰撞**：当堆顶(brk)与栈底距离小于安全阈值时触发 ENOMEM
- **共享库加载**：采用写时复制(COW)技术实现物理内存复用
- **高地址防护**：内核空间设置不可访问页，防止用户程序越界

建议通过 GDB 调试观察具体进程的/proc/[pid]/maps 文件内容，验证理论模型与实际内存布局的对应关系。
