# 定点数除法运算

## 摘要

采用恢复余数法和加减交替法实现定点数除法运算，通过硬件寄存器协同操作完成迭代减法过程，重点解决余数恢复策略和运算效率优化问题。最终实现商值精确到指定精度，余数满足数学约束。

## 主题

二进制除法硬件实现方法比较
**核心方法**：迭代减法、余数修正、寄存器移位  
**关键技术**：补码运算、符号位检测、路径优化  
**关联问题**：

1. 如何避免多次减法操作带来的延迟？
2. 余数恢复与直接修正的硬件开销差异？

> 重点难点
>
> - 补码运算实现余数符号判断（符号位 → 商值决策）
> - 恢复余数法的回退机制硬件实现
> - 加减交替法的路径优化原理

## 线索区

### 1. 运算基础原理

**数学定义**：  
被除数 $D = Q \times d + R$  
约束条件：$|R| < |d|$ 且 $R \cdot D \geq 0$

**硬件映射**：

- ACC：存储当前余数（初始为被除数）
- X：固定存储除数补码
- MQ：迭代生成商值（LSB 先行）

### 2. 恢复余数法流程

**迭代周期**（n+1 位精度需 n+1 步）：

1. 余数左移 1 位 → ACC
2. ACC ← ACC - X（减除数）
3. 检测 ACC 符号位：
   - **正**：MQ 末位置 1
   - **负**：ACC ← ACC + X（恢复），MQ 末位置 0

**关键参数**：

- **最差延迟**：$2n$ 次加法（n 位精度）
- **硬件需求**：双符号位检测电路

### 3. 加减交替法优化

**流程改进**：  
当余数为负时，下一周期直接执行：
$$ACC ← (ACC + X) \times 2 - X$$  
等效于跳过恢复步骤，将恢复操作合并到下一周期

**性能提升**：

- **固定延迟**：$n+1$ 次加法
- **硬件复用**：单符号位判断电路

### 4. 硬件实现细节

**寄存器配置**：  

| 寄存器 | 位宽 | 功能 |
|--------|------|------|
| ACC | n+1 | 余数存储，带双符号位 |
| X | n+1 | 除数补码存储 |
| MQ | n | 商值生成，带移位控制 |

**控制逻辑**：

```verilog
always @(posedge clk) begin
    if (cycle < n) begin
        ACC <= {ACC[n-1:0], MQ[MSB]};  // 左移
        temp = ACC - X;
        MQ <= {MQ[n-2:0], (temp[MSB] ? 1'b0 : 1'b1)};
        ACC <= temp[MSB] ? (ACC + X) : temp;
    end
end
```

## 总结区

**核心考点**：

1. 两种算法的时钟周期差异（恢复法 2n vs 交替法 n+1）
2. 余数符号位判断对商值的影响
3. MQ 寄存器的移位-置位时序

**易错点**：

- 忽略余数左移前的符号位扩展
- 错误理解加减交替法的合并操作原理
- 硬件实现时未考虑溢出保护

**设计权衡**：

- 恢复余数法：更直观但效率低
- 加减交替法：时序优化但控制复杂
- 现代 CPU 多采用 SRT 算法（本方法的扩展）

请确认是否需要针对特定硬件架构（如 74LS181）进行实现细节补充，或增加数值计算示例。
