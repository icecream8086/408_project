# 基址寻址与变址寻址

## 摘要

通过对比基址/变址/相对寻址的硬件实现与地址计算逻辑，解析三种偏移寻址方式在程序浮动、数组访问等场景中的应用差异，明确基址寄存器与变址寄存器的管理权限划分。

## 主题

| 寻址方式     | 寄存器管理      | 地址计算模型 | 典型应用场景      |
| ------------ | --------------- | ------------ | ----------------- |
| **基址寻址** | OS 控制 BR      | EA = BR + A  | 多道程序内存分配  |
| **变址寻址** | 程序员控制 IX   | EA = IX + A  | 数组遍历/循环控制 |
| **相对寻址** | 硬件自动更新 PC | EA = PC + A  | 代码段内部跳转    |

> 重点难点
>
> - 基址/变址寄存器的权限边界（OS vs 程序员）
> - 有效地址计算模型差异：$EA_{base} = BR + A$ vs $EA_{index} = IX + A$
> - 程序浮动的两种实现：基址寻址（全局浮动） vs 相对寻址（局部浮动）

## 线索区

### 知识点 1：基址寻址机制

**定义**：  
通过基址寄存器(BR)存储程序基准地址，与指令字中的形式地址(A)相加得到有效地址：

$$EA = BR + A$$

**硬件特性**：

- BR 由操作系统管理，用户程序不可修改
- **内存浮动原理**：通过调整 BR 值实现程序整体地址偏移（如：程序从 2000→3000 时，BR 从 2000→3000）

**典型应用**：

- 多道程序并发时的动态重定位
- 虚拟内存地址转换（配合页表基址寄存器）

![基址寻址示意图]()  
_图 1 基址寻址的地址生成流程_

---

### 知识点 2：变址寻址机制

**定义**：  
通过可编程变址寄存器(IX)存储偏移量，与形式地址相加：

$$EA = IX + A$$

**操作特性**：

- IX 由程序员显式控制（如：循环中`IX++`）
- **数组访问优化**：固定 A 为数组基址，动态修改 IX 遍历元素（例：A=1000 为数组首地址，IX 从 0 递增访问各元素）

**性能参数**：

- **访问效率**：单指令完成基址+变址计算（比软件计算快**3~5 个时钟周期**）
- **典型芯片**：Intel 8086 的 SI/DI 变址寄存器

---

### 知识点 3：复合寻址模式

**基址变址寻址**：  
$$EA = BR + IX + A$$  
_应用场景_：二维数组访问（BR=行基址，IX=列偏移）

**硬件支持**：

- MIPS 架构：通过`lw $t0, offset($base)`指令实现
- x86 架构：`MOV [BX+SI+10H], AX` 形式

---

## 总结区

### 核心对比表

| 特征           | 基址寻址 | 变址寻址 | 相对寻址 |
| -------------- | -------- | -------- | -------- |
| **管理权限**   | OS       | 程序员   | 硬件     |
| **寄存器类型** | BR       | IX       | PC       |
| **浮动范围**   | 全局程序 | 局部数据 | 代码段内 |
| **典型应用**   | 多道程序 | 数组遍历 | 条件跳转 |

### 考点分析

1. **计算题**：给定 BR=2000H, IX=100H, A=50H，计算各寻址方式的 EA：

   - 基址：2000H + 50H = 2050H
   - 变址：100H + 50H = 150H
   - 复合：2000H + 100H + 50H = 2150H

2. **设计题**：使用变址寻址实现数组求和（伪代码）：

   ```assembly
   MOV IX, 0       ; 初始化变址寄存器
   MOV SUM, 0      ; 清空累加器
   LOOP:
   ADD SUM, A(IX)  ; A为数组基址
   INC IX          ; 变址寄存器自增
   CMP IX, 100     ; 检查循环终止
   JL LOOP
   ```

3. **概念辨析**：基址寻址与动态重定位的关系（BR 值修改等效于程序整体地址平移）

需要补充具体数值案例或硬件实现细节吗？


[4.3.4 循环语句的机器级表示](4.3.4%20循环语句的机器级表示.md)
