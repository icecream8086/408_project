# 函数调用与栈帧切换

## 摘要

通过分析 x86 架构函数调用机制，揭示栈帧切换原理。重点解析`call`/`leave`/`ret`指令工作流程，建立寄存器操作与栈空间变化的对应关系，为逆向工程和性能优化提供理论基础。

## 主题

栈帧管理机制与指令集协同工作原理（关键词：栈帧、EBP 基址指针、ESP 栈指针、调用约定）

> 重点难点
>
> - 调用现场保存的完整性：返回地址+寄存器状态
> - EBP 链式寻址实现原理
> - leave 指令等效操作分解

## 线索区

### 知识点 1：栈帧结构模型

```latex
高地址 → | 参数n    | ← EBP+8
         | ...      |
         | 参数1    |
         | 返回地址 | ← EBP+4
当前帧 → | 旧EBP    | ← EBP
         | 局部变量 | ← EBP-4
         | ...      |
低地址 → | 临时数据 | ← ESP
```

- **寄存器分工**：
  - EBP：帧基址锚点，通过`[EBP±offset]`访问参数/局部变量
  - ESP：动态栈顶指针，总指向最后入栈数据

### 知识点 2：关键指令语义

1. `call func`：

   - 隐式操作：`push EIP` → `jmp func`
   - 副作用：ESP-=4（32 位模式）

2. 序言(prologue)：

   ```nasm
   push ebp       ; 保存调用者帧指针（ESP-=4）
   mov ebp, esp   ; 确立新帧基准点
   sub esp, N     ; 分配局部变量空间
   ```

3. 收尾(epilogue)：

   ```nasm
   leave          ; ≡ mov esp,ebp → pop ebp
   ret            ; ≡ pop EIP
   ```

### 知识点 3：调用约定差异

| 约定类型 | 参数传递    | 栈清理方 | 寄存器保存  |
| -------- | ----------- | -------- | ----------- |
| cdecl    | 右 → 左入栈 | 调用者   | EAX,ECX,EDX |
| stdcall  | 右 → 左入栈 | 被调者   | EAX,ECX,EDX |
| fastcall | 部分寄存器  | 被调者   | EBX,ESI,EDI |

## 总结区

**核心考点**：

1. 栈帧切换时寄存器的级联保存机制
2. leave 指令等价操作分解（ESP 复位+EBP 恢复）
3. 不同调用约定对反汇编分析的影响

**优化实践**：

- 尾调用优化：复用栈帧时省略序言/收尾代码
- **帧指针省略**：编译选项`-fomit-frame-pointer`通过 ESP 直接寻址提升性能

**典型错误**：

- 栈不平衡（如 cdecl 调用后未清理参数）
- EBP 链断裂导致栈回溯失败
- 未对齐访问引发性能惩罚（SSE 操作需 16 字节对齐）

该知识体系为理解缓冲区溢出、多线程栈管理等进阶主题奠定基础，建议结合 GDB 调试实验验证理论模型。
