# 函数调用的机器级表示

## 摘要

本讲解析 x86 架构下函数调用的机器级实现，通过栈帧结构分析、寄存器操作追踪、汇编指令解读三层次展开。核心展示`call/ret`指令的原子操作、参数传递机制、栈空间分配原理及其与高级语言特性的映射关系。

---

## 主题

> **栈式内存管理在函数调用中的实现**

- 核心方法：基址指针（EBP）相对寻址 + 栈指针（ESP）动态调整
- 关键技术：
  1. 调用约定（cdecl）
  2. 栈帧生命周期管理
  3. 参数-局部变量寻址偏移计算

> 重点难点
>
> - 栈帧切换时的寄存器状态机变迁
> - 参数传递的逆向偏移规律（`EBP+8`起）
> - 局部变量对齐对 ESP 操作的影响

---

## 线索区

### 1. 栈帧拓扑结构

**定义**：连续内存区域，存储函数执行上下文  
**组成**（自上而下）：

```txt
| 参数n     | EBP+12
| ...       |
| 参数1     | EBP+8
| 返回地址  | EBP+4
| 旧EBP     | EBP
| 局部变量1 | EBP-4
| ...       |
| 局部变量n | EBP-4n
```

**类比**：

- 栈帧如同档案盒，EBP 是盒体定位钉，ESP 指示当前操作层

### 2. 调用指令原子操作

**`call func`等价操作**：

```assembly
push eip+1    ; 压入返回地址
jmp func       ; 跳转目标函数
```

**`ret`指令逆向过程**：

```assembly
pop eip        ; 恢复执行流
add esp, n*4   ; 清理参数区（调用者负责）
```

### 3. 参数传递机制

**cdecl 约定规则**：

1. 参数逆序压栈（右 → 左）
2. 调用者维护栈平衡
3. 返回值通过 EAX 传递

**典型代码段**：

```assembly
; 调用add(3,5)
push 5       ; 参数2
push 3       ; 参数1
call add
add esp, 8   ; 清理栈空间
```

### 4. 局部变量存储

**空间分配**：

```assembly
sub esp, 12  ; 分配3个int变量空间
mov [ebp-4], 0 ; 初始化var1
```

**对齐原则**：

- 默认 4 字节对齐（32 位模式）
- 结构体变量可能引发填充字节

---

## 总结区

**核心概念拓扑**：

```txt
栈帧生命周期
  ├─ 创建阶段（call指令触发）
  ├─ 活跃阶段（EBP锚定访问）
  └─ 销毁阶段（leave/ret指令）
```

**高频考点**：

1. 根据汇编代码还原函数原型
2. 计算局部变量栈偏移量
3. 识别参数传递顺序错误

**现实映射**：

- 缓冲区溢出漏洞本质是破坏了栈帧结构
- 递归调用深度受栈空间限制

**性能指标**：

- 栈操作指令占比约**35%**的典型函数
- 寄存器传参可减少**40%**内存访问

> 下阶重点预告：异常处理中的栈展开（stack unwinding）机制

格式修订说明：

1. 增加内存布局示意图强化空间认知
2. 使用伪代码段明确指令等效操作
3. 通过拓扑图展示概念关联性
4. 补充安全相关延申知识点
