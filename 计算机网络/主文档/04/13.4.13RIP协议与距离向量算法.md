# 路由选择与距离向量算法

## 摘要
本课程解析距离向量算法在RIP协议中的实现，通过**路由表更新实验**和**最短路径计算推演**，揭示路由收敛机制与协议特性。结合Wireshark抓包验证，最终得出RIP协议适用于小型网络但存在慢收敛缺陷的结论。

## 主题
**网络层路由协议实现原理**  
核心方法：分布式最短路径计算、周期性路由表同步  
关键协议：RIP（Routing Information Protocol）  
核心问题：  
- 如何通过邻居通告实现全网路由收敛？  
- 慢收敛问题为何会导致路由黑洞？

> 重点难点
>
> - 距离向量算法迭代过程（Bellman-Ford方程应用）
> - 毒性逆转与水平分割的防环机制对比
> - 最大跳数16的协议设计边界

## 线索区

### 知识点1: 距离向量算法原理（网络层）
```math
d_x(y) = \min_v\{c(x,v) + d_v(y)\}
```
- **状态机**：周期性更新（30s）→ 邻居失效检测（180s）→ 毒性传播（metric=16）
- **实验验证**：
  ```bash
  # Linux查看RIP路由表
  ip route show proto rip
  # 抓取RIP更新包
  tcpdump -i eth0 -vvv -n udp port 520
  ```
- **Wireshark过滤**：`rip && udp.port == 520`

### 知识点2: 路由表更新实例
| 目的网络 | 原距离 | 新通告距离 | 更新后距离 | 下一跳 |
|---------|-------|------------|------------|--------|
| NetA    | 7     | R4:4       | **4+1=5**  | R4     |
| NetB    | 16    | R4:2       | 2+1=3      | R4     |

**更新逻辑**：  
1. 接收邻居R4的通告距离  
2. 计算新距离=通告值+链路成本（默认+1跳）  
3. 仅当新距离小于当前值时更新

### 知识点3: 慢收敛问题（传输层/应用层）
- **现实类比**：城市停电时，蜡烛抢购信息传递延迟导致商店反复缺货
- **解决方案对比表**：
  | 机制         | 原理                   | 缺点               |
  |--------------|------------------------|--------------------|
  | 水平分割     | 不从接收端口回发路由   | 无法防多节点环路   |
  | 毒性逆转     | 对接收端口回发∞度量    | 增加报文尺寸       |
  | 触发更新     | 立即广播变化           | 可能产生更新风暴   |

### 知识点4: RIP协议特性（应用层）
- **协议帧结构**：
  ```
  | Command(1B) | Version(1B) | Zero(2B) |
  | AFI(2B)     | Route Tag(2B)| IP地址(4B) |
  | Subnet Mask(4B) | Next Hop(4B) | Metric(4B) |
  ```
- **关键参数**：  
  **最大跳数16**（设计约束）  
  **更新周期30s**（UDP 520端口）  
  **无效计时器180s**

## 总结区

**核心考点**：  
1. 距离向量算法迭代过程（需手工推导路由表更新）  
2. RIP防环机制选择（笔试常考水平分割与毒性逆转区别）  
3. 协议局限性分析（对比链路状态协议）

**实验重点**：  
- 通过`tcpdump`捕获RIP更新报文，解析metric变化过程  
- 在GNS3中构建路由环路，观察收敛时间与丢包情况

**进阶思考**：  
当网络直径超过15跳时，为何不能简单增大RIP的最大跳数值？（涉及协议兼容性与计数到无穷问题）