# 海明码与差错控制

## 摘要
本课程系统解析海明码的差错控制原理，通过数学建模与实验验证方法，构建可实操的编码验证方案。重点阐述校验码生成算法、海明距离计算规则，并通过二进制位操作演示单比特纠错过程。

## 主题
海明码通过校验矩阵实现单比特错误定位与纠正，其核心参数海明距离决定编码系统的检错/纠错能力。课程涵盖编码构造、校验方程推导及典型应用场景分析。

> **重点难点**
> - 校验码位数计算公式 `2^R ≥ M + R + 1` 的工程应用
> - 校验位与数据位的空间映射关系
> - 海明距离对编码效能的数学约束

## 线索区

### 协议分层定位
`数据链路层` > `差错控制编码`

### 知识点1：海明码架构模型
```math
\begin{cases}
r_1 = d_1 \oplus d_2 \oplus d_4 \\
r_2 = d_1 \oplus d_3 \oplus d_4 \\
r_3 = d_2 \oplus d_3 \oplus d_4
\end{cases}
```
- **校验位布局**：2^n位置（1,2,4,8...）插入校验位
- **覆盖关系**：每个数据位被多个校验位覆盖（二进制索引决定）
- **实例**：7位海明码（4位数据+3位校验）的位排列：
  ```
  P1 P2 D1 P3 D2 D3 D4
  ```

### 知识点2：海明距离计算
**定义**：两个码字不同比特位数  
**数学表达式**：  
对于码字$C_i$和$C_j$，海明距离$d_{min} = \sum_{k=1}^n (c_{i,k} \oplus c_{j,k})$  

**纠错能力判定**：
| 海明距离 | 检测能力 | 纠正能力 |
|---------|---------|---------|
| d ≥ 2   | 单比特   | 无       |
| d ≥ 3   | 双比特   | 单比特   |
| d ≥ 4   | 三比特   | 单比特   |

### 知识点3：差错控制实验方法
**实验环境**：  
`Python 3.8+` | `bitstring`库  

**关键操作**：
```python
def hamming_encode(data_bits):
    # 计算校验位
    p1 = data_bits[0] ^ data_bits[1] ^ data_bits[3]
    p2 = data_bits[0] ^ data_bits[2] ^ data_bits[3]
    p3 = data_bits[1] ^ data_bits[2] ^ data_bits[3]
    return [p1, p2, data_bits[0], p3, data_bits[1], data_bits[2], data_bits[3]]
```

**故障注入测试**：
```bash
# 生成错误码示例
echo "原始码: 1011001" 
echo "错误码: 1011011 (第5位翻转)"
```

## 总结区

### 核心公式
- **校验位计算**：$r_k = \bigoplus_{i=1}^n (b_i \cdot mask_k)$  
- **纠错定位**：错误位置 = $\sum_{k=1}^R (s_k \times 2^{k-1})$

### 典型考点
1. **校验位数量计算**：给定数据长度M，求最小R值（常考M=16时R=5）
2. **纠错过程推演**：根据校验结果反推错误位置（二进制转十进制）
3. **编码效率对比**：海明码冗余度 $\eta = R/(M+R)$ 的优化分析

### 实验验证要点
- **错误模式验证**：单比特错误必须100%纠正
- **边界测试**：全0/全1数据的编码稳定性
- **性能基准**：**编码延迟 < 1μs/bit**（FPGA实现标准）

---

本结构通过分层解析、数学建模与代码验证三维度构建知识体系，满足协议分析→算法实现→故障复现的全链路学习需求。建议结合Wireshark的**Bit Error Rate Testing**功能进行实时观测验证。