# GB N协议与滑动窗口机制

## 摘要
本课解析Go-Back-N协议在传输层的实现机制，通过**流水线技术**提升信道利用率，结合**滑动窗口**与**累积确认**实现可靠传输。实验验证表明当窗口尺寸达到$2^n-1$时协议效能最优，但存在错误帧引发批量重传问题，引出改进方案SR协议。

## 主题
传输层可靠传输核心机制（GBN/SR协议对比）  
`滑动窗口控制` `累积确认` `超时重传` `帧编号约束`  
❓如何通过Wireshark观测GBN协议的重传行为？

> 重点难点
> - 窗口尺寸与帧编号位数的数学关系（$W_{max}=2^n-1$）
> - 接收窗口固定为1带来的帧丢弃现象
> - 批量重传对网络吞吐量的影响

## 线索区

### [传输层] GBN协议状态机
```latex
\begin{figure}[h]
\centering
\caption{GBN协议状态转换}
\begin{tikzpicture}
\node[state] (send) {发送窗口}; 
\node[state, right=of send] (wait) {等待ACK};
\draw[->] (send) edge[bend left] node[above] {发送N帧} (wait);
\draw[->] (wait) edge[bend left] node[below] {收到ACK} (send);
\draw[->] (wait) edge[loop right] node {超时重传} ();
\end{tikzpicture}
\end{figure}
```
**协议帧结构**：  
| 2字节类型 | 4字节序列号 | 数据载荷 | 2字节CRC |

**实验验证命令**：  
```bash
# Linux环境模拟丢包（20%丢包率）
tc qdisc add dev eth0 root netem loss 20%
tcpdump -i eth0 -w gbn.pcap 'ip proto 0x7F'  # 捕获自定义协议流量
```

### [传输层] 滑动窗口机制
**窗口动态演示**：  
发送窗口尺寸N=4时：  
`[1][2][3][4]` → ACK2到达 → `[3][4][5][6]`

**关键约束公式**：  
$$\text{发送窗口最大值} = 2^n - 1 \quad (n=\text{序列号位数})$$

**Wireshark过滤技巧**：  
`tcp.analysis.retransmission` 可检测TCP重传（类比GBN机制）

### [协议对比] GBN vs SR
| 特性        | GBN                     | SR                      |
|-------------|-------------------------|-------------------------|
| 接收窗口    | 固定为1                 | 可变大小                |
| 重传策略    | 批量重传未确认帧        | 选择性重传错误帧        |
| 缓冲要求    | 仅需发送方缓冲          | 收发双方均需缓冲        |
| 适用场景    | 低错误率环境            | 高错误率环境            |

## 总结区

**核心结论**：  
- GBN通过$W_{max}=2^n-1$保证帧序鉴别能力
- 累积确认减少50%以上的控制报文开销
- 批量重传机制在丢包率>15%时吞吐量下降明显

**实验设计考点**：  
1. 通过`tc`命令模拟网络丢包环境  
2. 使用**tcpdump**抓取重传报文（注意时间戳分析）  
3. 窗口尺寸与吞吐量的非线性关系验证

**工程类比**：  
- 滑动窗口 → 高速公路ETC多车道通行系统  
- 累积确认 → 物流中心批量签收货物  
- 超时重传 → 快递未收到签收通知自动重发  

**进阶思考**：  
当物理层误码率达到$10^{-3}$时，GBN与SR协议的吞吐量拐点出现在什么窗口尺寸？  
（提示：使用NS3仿真工具建模分析）