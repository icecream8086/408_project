# 开放定址法与散列表冲突处理

## 摘要

本视频介绍了散列表中处理冲突的开放定址法，包括其基本思想、探测序列的设计、四种常用的探测方法（线性探测法、平方探测法、双散列法和伪随机序列法），以及删除操作对散列表性能的影响。视频还讨论了如何通过定期整理散列表来提高查找效率。

## 主题

开放定址法是一种处理散列表冲突的方法，其核心思想是通过设计探测序列来寻找空闲位置。视频详细介绍了四种探测序列的设计方法及其应用场景，并强调了逻辑删除在散列表操作中的重要性。

> 重点难点
>
> - 探测序列的设计与覆盖率问题
> - 逻辑删除与物理删除的区别及其对查找效率的影响
> - 不同探测方法的应用场景及其优缺点

## 线索区

### 开放定址法的基本思想
- 当插入元素时，如果散列函数计算的地址发生冲突，则寻找另一个空闲位置。
- 开放定址法的名称来源于一个散列地址既可以存储同一词，也可以存储非同一词。
- 需要设计一个规则来确定下一个空闲位置，例如从原始地址向右或向左偏移。

### 探测序列的设计
- 探测序列的设计是开放定址法的核心，$d_i$表示第$i$次冲突时的偏移量。
- 散列地址的计算公式为：初始散列地址 + 探测序列的$d_i$个偏移量，再对表长$m$取余。
- 四种常用的探测序列构造方法：线性探测法、平方探测法、双散列法和伪随机序列法。

### 线性探测法的应用
- 线性探测法的例子：散列表长度为13，散列函数为关键字对13取余。
- 插入元素1的过程：初始散列地址为1，发生冲突后依次探测2、3、4，最终插入到4。
- 查找操作的原理与插入操作类似，依次探测直到匹配成功或遇到空位。

### 平方探测法的介绍
- 平方探测法（二次探测法）的探测序列规律：初始地址偏移量为0，冲突后依次探测$1^2$、$-1^2$、$2^2$、$-2^2$等。

### 双散列法的应用
- 双散列法的探测序列由第二个散列函数决定。
- 插入元素1时，初始散列地址为1，发生冲突后使用第二个散列函数计算下一个探测位置，最终插入到地址11。

### 伪随机序列法的应用
- 伪随机序列法通过人为设计的序列来探测位置。
- 插入元素1时，初始散列地址为1，发生冲突后按照伪随机序列探测，最终插入到地址4。

### 删除操作及其影响
- 删除元素时，首先查找该元素，找到后进行逻辑删除。
- 逻辑删除可以避免探测路径中断，确保查找操作的正确性。
- 删除操作导致散列表看起来很满，但实际上很空，查找效率会严重降低。

### 解决散列表查找效率低下的方法
- 定期整理散列表中的数据，将元素挪回初始散列地址并物理清空其他位置。
- 插入新元素时，可以插入到逻辑删除的位置。

### 探测序列的覆盖率
- 线性探测法可以保证最多发生$m-1$次冲突，探测完整个散列表。
- 平方探测法在表长$m$为$4j+3$的素数时，可以探测到所有位置。
- 双散列法的覆盖率取决于第二个散列函数的值是否与表长$m$互质。
- 伪随机序列法的覆盖率取决于序列设计是否合理。

## 总结区

本视频详细介绍了开放定址法及其在散列表中的应用，重点讲解了四种探测序列的设计方法及其优缺点。逻辑删除在散列表操作中至关重要，删除操作不当会导致查找效率低下。通过定期整理散列表，可以有效提高查找效率。不同探测方法的覆盖率问题也需要特别注意，线性探测法在任何情况下都能探测到所有地址，而其他方法则需要满足特定条件。