# 双端队列

## 摘要

本节介绍了双端队列的概念、特点及其变种，重点分析了输入受限和输出受限双端队列的合法输出序列判断方法，并引入了卡特兰数的应用。通过学习，掌握双端队列的操作特性及其与栈、队列的区别。

## 主题

双端队列是一种允许从两端插入和删除的线性表，其变种包括输入受限和输出受限双端队列。核心方法是通过模拟操作判断序列的合法性，卡特兰数用于计算栈的合法出栈序列数。

> 重点难点
>
> - 双端队列的定义及其与栈、队列的区别
> - 输入受限和输出受限双端队列的合法序列判断
> - 卡特兰数的应用及其局限性

## 线索区

### 知识点 1：双端队列的定义与特点

- **定义**：双端队列（Deque）是一种允许从**前端（front）**和**后端（rear）**进行**插入**和**删除**的线性表。
- **特点**：
  - 灵活性高，支持双端操作。
  - 与栈（LIFO）和队列（FIFO）相比，操作更灵活。
- **变种**：
  - **输入受限双端队列**：仅允许一端插入，两端均可删除。
  - **输出受限双端队列**：仅允许一端删除，两端均可插入。

#### 双端队列的操作

双端队列通常支持以下基本操作：

1. **插入操作**：
   - `push_front(x)`：在队列的前端插入元素 `x`。
   - `push_back(x)`：在队列的后端插入元素 `x`。
2. **删除操作**：
   - `pop_front()`：删除并返回队列前端的元素。
   - `pop_back()`：删除并返回队列后端的元素。
3. **访问操作**：
   - `front()`：返回队列前端的元素（不删除）。
   - `back()`：返回队列后端的元素（不删除）。
4. **辅助操作**：
   - `isEmpty()`：判断队列是否为空。
   - `size()`：返回队列中元素的个数。

### 合法输出序列判断

- **栈**：
  - 合法序列需满足“任意前缀中进栈 ≥ 出栈”。
  - 合法例：`1234`, `3241`。
  - 非法例：`2413`。
- **双端队列**：
  - **输入受限**：插入端固定，删除可两端交替进行。
    - 合法例：`1423`, `3142`。
    - 非法例：`2413`。
  - **输出受限**：删除端固定，插入可两端交替进行。
    - 合法例：`1423`。
    - 非法例：`4132`。

> **案例代码**

```cpp
#include <stdio.h>
#include <stdbool.h>

#define MAX_SIZE 100  // 定义队列的最大容量

typedef struct {
    int data[MAX_SIZE];  // 存储队列元素的数组
    int front;           // 指向队列前端的指针
    int rear;            // 指向队列后端的指针
    int size;            // 当前队列的大小
} Deque;

void initDeque(Deque* dq) {
    dq->front = -1;
    dq->rear = 0;
    dq->size = 0;
}

bool isEmpty(Deque* dq) {
    return dq->size == 0;
}

bool isFull(Deque* dq) {
    return dq->size == MAX_SIZE;
}

void push_front(Deque* dq, int item) {
    if (isFull(dq)) {
        printf("队列已满，无法插入\n");
        return;
    }
    if (dq->front == -1) {  // 队列为空时初始化
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->front == 0) {  // 处理循环数组的边界
        dq->front = MAX_SIZE - 1;
    } else {
        dq->front--;
    }
    dq->data[dq->front] = item;
    dq->size++;
}

void push_back(Deque* dq, int item) {
    if (isFull(dq)) {
        printf("队列已满，无法插入\n");
        return;
    }
    if (dq->front == -1) {  // 队列为空时初始化
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->rear == MAX_SIZE - 1) {  // 处理循环数组的边界
        dq->rear = 0;
    } else {
        dq->rear++;
    }
    dq->data[dq->rear] = item;
    dq->size++;
}

int pop_front(Deque* dq) {
    if (isEmpty(dq)) {
        printf("队列为空，无法删除\n");
        return -1;
    }
    int item = dq->data[dq->front];
    if (dq->front == dq->rear) {  // 队列中只有一个元素
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->front == MAX_SIZE - 1) {  // 处理循环数组的边界
        dq->front = 0;
    } else {
        dq->front++;
    }
    dq->size--;
    return item;
}

int pop_back(Deque* dq) {
    if (isEmpty(dq)) {
        printf("队列为空，无法删除\n");
        return -1;
    }
    int item = dq->data[dq->rear];
    if (dq->front == dq->rear) {  // 队列中只有一个元素
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->rear == 0) {  // 处理循环数组的边界
        dq->rear = MAX_SIZE - 1;
    } else {
        dq->rear--;
    }
    dq->size--;
    return item;
}

int getFront(Deque* dq) {
    if (isEmpty(dq)) {
        printf("队列为空\n");
        return -1;
    }
    return dq->data[dq->front];
}

int getBack(Deque* dq) {
    if (isEmpty(dq)) {
        printf("队列为空\n");
        return -1;
    }
    return dq->data[dq->rear];
}

int getSize(Deque* dq) {
    return dq->size;
}

int main() {
    Deque dq;
    initDeque(&dq);
    push_back(&dq, 10);
    push_front(&dq, 20);
    push_back(&dq, 30);
    printf("前端元素: %d\n", getFront(&dq));
    printf("后端元素: %d\n", getBack(&dq));
    printf("删除前端元素: %d\n", pop_front(&dq));
    printf("删除后端元素: %d\n", pop_back(&dq));
    printf("队列大小: %d\n", getSize(&dq));
    return 0;
}
```

### 知识点 3：卡特兰数

- **公式**：
  $$ C_n = \frac{1}{n+1} \binom{2n}{n} $$
- **应用**：
  - 计算栈的合法出栈序列数。
  - **不适用双端队列**：双端队列的合法序列数 > 卡特兰数。

## 总结区

- **核心概念**：双端队列支持双端操作，其变种包括输入受限和输出受限双端队列。
- **合法序列判断**：通过模拟操作验证序列合法性，注意双端队列的灵活性。
- **卡特兰数**：仅适用于栈的合法出栈序列数，双端队列需另分析。
- **考点延伸**：
  - 判断给定序列是否合法。
  - 对比栈、队列、双端队列的操作特性。
  - 计算栈的合法出栈序列数（卡特兰数）。
