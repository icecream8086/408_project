# [图论] 图的邻接表存储方式

## 摘要

介绍图的邻接表存储实现原理，对比邻接矩阵的时空效率差异。通过链式存储优化稀疏图空间利用率（O(V+E)），分析度计算的时间复杂度差异，给出不同场景下的存储选择策略。

## 主题

邻接表使用数组+链表的复合结构实现图存储，在空间效率与操作效率间取得平衡。重点掌握其存储结构设计、度计算实现差异及与邻接矩阵的对比维度。

> 重点难点
>
> - 链式存储结构的内存分布特征
> - 有向图入度计算的效率瓶颈
> - 稀疏/稠密图场景下的选择依据

## 线索区

### 1. 存储结构设计

```python
class GraphNode:
    def __init__(self, val):
        self.val = val
        self.edges = []  # 边链表头指针

# 示例：无向图存储
graph = [
    GraphNode('A'),  # 索引0 -> 边[B,C,D]
    GraphNode('B'),  # 索引1 -> 边[A]
    # ...其他节点
]
```

- **顺序存储**：顶点数组保存节点基本信息
- **链式扩展**：每个节点维护边链表，存储邻接关系
- **空间复杂度**：无向图 O(V+2E)，有向图 O(V+E)

### 2. 度计算实现

| 图类型 | 度类型 | 计算方法             | 时间复杂度 |
| ------ | ------ | -------------------- | ---------- |
| 无向图 | 度     | 直接统计边链表长度   | O(1)       |
| 有向图 | 出度   | 统计边链表长度       | O(1)       |
| 有向图 | 入度   | 遍历所有节点的边链表 | O(V+E)     |

### 3. 对比矩阵（邻接表 vs 邻接矩阵）

| 维度       | 邻接矩阵        | 邻接表          |
| ---------- | --------------- | --------------- |
| 空间复杂度 | O(V²)           | O(V+E)          |
| 查边操作   | O(1)            | O(degree(v))    |
| 遍历邻接点 | O(V)            | O(degree(v))    |
| 适用场景   | 稠密图/频繁查边 | 稀疏图/频繁遍历 |
| 数据冗余   | 无              | 无向图双倍存储  |

### 4. 工程优化实践

- **逆邻接表**：为快速获取入度单独建立反向边表
- **链式结构选择**：数组模拟链表提升缓存命中率

```cpp
// 数组模拟链表示例（C++）
struct Edge {
    int to, next;  // next存储下条边的数组下标
};
vector<Edge> edges;
vector<int> head;  // 顶点数组
```

## 总结区

1. **核心考点**：

   - 邻接表的链式存储实现方式
   - 不同图类型下的空间复杂度计算
   - 入度计算的效率缺陷及解决方案

2. **真题模式**：

   - LeetCode 207（拓扑排序入度统计）
   - PAT A1134（顶点覆盖的邻接表遍历）

3. **易错点**：
   - 混淆无向图与有向图的边存储数量
   - 未考虑逆邻接表对入度计算的优化
   - 错误估算遍历邻接点的时间复杂度
