# 图的广度优先搜索（BFS）与时间复杂度分析

## 摘要

**目的**：掌握图结构的层序遍历方法与性能评估  
**方法**：队列辅助实现 + 标记数组防重复访问  
**结论**：

- 邻接表时间复杂度 O(V+E)，邻接矩阵 O(V²)
- 非连通图需多次调用 BFS 生成森林
- 生成树保留 N-1 条边，形成无环结构

---

## 主题

**核心方法**：队列驱动层序扩展，标记数组记录访问状态  
**关键词**：

- 邻接矩阵 vs 邻接表
- 生成森林
- 空间复杂度 O(V)

> **重点难点**
>
> 1. 邻接表时间效率优势的来源（避免无效扫描）
> 2. 非连通图遍历的**扫描-重入**机制
> 3. 有向图遍历路径的**方向敏感性**

---

## 线索区

### 1. BFS 算法框架（邻接表实现）

**核心思想**：

```python
def bfs(graph, start):
    visited = [False] * len(graph)
    queue = deque()
    queue.append(start)
    visited[start] = True

    while queue:
        u = queue.popleft()
        for v in graph[u]:
            if not visited[v]:
                visited[v] = True
                queue.append(v)
```

**关键操作**：

1. 入队时立即标记访问（防止重复入队）
2. 严格保持 FIFO 顺序

**LeetCode 例题**：

- [127. 单词接龙](https://leetcode.com/problems/word-ladder/)
- [200. 岛屿数量](https://leetcode.com/problems/number-of-islands/)

---

### 2. 时间复杂度对比分析

| 存储结构 | 时间复杂度 | 原因解析                    |
| -------- | ---------- | --------------------------- |
| 邻接矩阵 | O(V²)      | 每个顶点需扫描 V 个矩阵元素 |
| 邻接表   | O(V + E)   | 顶点访问 + 边遍历的线性时间 |

**数学推导**（邻接表）：  
$$\sum_{v=1}^{V}[1 + deg(v)] = V + 2E = O(V + E)$$

---

### 3. 生成树构造演示

**动画分解步骤**：

1. 选择起点 A，标记为红色
2. 遍历 A 的邻接点 B、C，标红边 AB、AC
3. B 访问其未标记邻接点 D，标红边 BD
4. 循环直到所有可达节点被标红

**边界条件**：

```cpp
// 处理孤立节点
if (!visited[i]) {
    bfs(graph, i);  // 对每个未访问节点发起遍历
}
```

---

### 4. 非连通图处理机制

**现实类比**：

- 类似在不同岛屿间架设桥梁，每个岛屿独立建立交通网

**实现模式**：

```python
def bfs_forest(graph):
    visited = [False] * len(graph)
    for v in range(len(graph)):
        if not visited[v]:
            bfs(graph, v, visited)  # 每个连通分量启动一次BFS
```

---

## 总结区

**核心考点**：

1. 空间复杂度计算（队列最大长度 = 层最大节点数）
2. 生成树边数必为 V-1 的证明
3. 对比 DFS 的空间复杂度（显式栈 vs 递归调用栈）

**优化技巧**：

- 邻接表使用**前向星**存储提升缓存命中率
- 双向 BFS 优化搜索效率（适用于终点明确场景）

>**题型映射**：  

| 问题类型 | 特征 | 例题编号 |
|----------------|--------------------|-------------|
| 层序遍历 | 要求保留层级信息 | 102, 429 |
| 最短路径 | 未加权图最优路径 | 847, 1971 |
| 连通分量计数 | 统计独立区域数量 | 323, 200 |
