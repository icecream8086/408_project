# 图的基本操作与性能分析

## 摘要

**目的**：对比图结构在邻接矩阵与邻接表存储方式下的操作性能  
**方法**：系统分析 12 种基本操作的时间复杂度特征  
**结论**：邻接矩阵在随机访问占优，邻接表在稀疏场景更高效  
**考点**：插入/删除顶点、查找邻接点操作的时间复杂度差异

---

## 主题

图论基础操作性能对比（邻接矩阵 vs 邻接表）  
**关键词**：时间复杂度、稀疏图、稠密图、入边查找  
**核心问题**：

- 如何根据应用场景选择存储结构？
- 哪些操作可能成为性能瓶颈？

> **重点难点**
>
> - 删除顶点时邻接矩阵的 O(V)时间来源
> - 邻接表查找入边需遍历全图的底层机制
> - 插入顶点时两种结构的时间复杂度等价性

---

## 线索区

### 操作复杂度对比表（V:顶点数，E:边数）

| 操作 \ 结构      | 邻接矩阵      | 邻接表           |
| ---------------- | ------------- | ---------------- |
| 判断边存在       | O(1)          | O(V)             |
| 插入顶点         | O(V²)→ 需扩容 | O(1)             |
| 删除顶点         | O(V)          | O(E)（最坏情况） |
| 查找第一个邻接点 | O(V)          | O(1)             |
| 遍历所有邻接点   | O(V)          | O(degree(v))     |

### 关键操作解析

#### 1. 顶点删除流程

```python
# 邻接矩阵删除顶点v（伪代码）
def delete_vertex(matrix, v):
    n = len(matrix)
    for i in range(n):        # 清空行：O(V)
        matrix[i][v] = INF
    for j in range(n):        # 清空列：O(V)
        matrix[v][j] = INF
    # 实际实现可能需要标记删除
```

#### 2. 入边查找困境

邻接表仅存储出边信息，查找入边需全图扫描：

```text
类比现实：要找出"谁给张三寄过快递"，需遍历所有快递记录
时间复杂度：O(E) → 遍历所有边检查终点是否为v
优化方案：维护逆邻接表（空间换时间）
```

### 典型考题模式

1. 给定图规模（V=1000, E=10000），选择最优存储结构
2. 分析 DFS/BFS 遍历时的时间复杂度差异
3. 设计支持快速入边查询的改进存储方案

---

## 总结区

### 考点提炼

1. **高频对比项**：

   - 判断边存在：矩阵 O(1) vs 邻接表 O(V)
   - 遍历邻接点：矩阵 O(V) vs 邻接表 O(1)~O(V)

2. **易错点**：
   - 邻接表插入顶点时间复杂度 ≠ 扩容时间（预设容量情况下）
   - 删除顶点时邻接表的边清除需要遍历所有链表

### 优化策略

- **稠密图**优先选择邻接矩阵（E 接近 V²）
- **需要频繁查询入边**时采用逆邻接表
- **动态扩容**场景下考虑分块矩阵设计

### 复杂度记忆口诀

```text
矩阵查边快如电，邻接遍历更灵便
删顶矩阵清行列，邻表扫边效率减
入边查询是痛点，逆表空间换时间
```

> **考研真题提示**：2016 年 408 真题第 41 题考察删除顶点对两种存储结构的影响，需注意题目是否要求物理删除还是逻辑删除。
