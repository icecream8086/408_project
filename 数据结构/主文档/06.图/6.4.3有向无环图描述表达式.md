# 有向无环图（DAG）的构造与优化

## 摘要

本笔记系统阐述有向无环图（DAG）的核心概念与优化方法。通过分层策略和操作符合并技术实现表达式结构的压缩，降低计算复杂度。结合代码模板与 408 真题案例，提供可操作的 DAG 构建范式。

---

## 主题

**图论 | 表达式优化**  
通过 DAG 消除算术表达式中的冗余计算，核心在于分层合并策略与操作符生效次序控制。重点解决公共子表达式识别与内存优化问题。

> **重点难点**
>
> - DAG 拓扑结构特征验证（环路检测算法）
> - 跨层操作符合并的可行性判断
> - 操作符执行顺序对 DAG 压缩率的影响

---

## 线索区

### 1. DAG 基础特性

**定义**：有向无环图（Directed Acyclic Graph, DAG）是边有方向且无环路的图结构，满足：
$$\forall v \in V, \nexists \ path\ v \rightarrow v$$  
> **与树结构的区别**：  

| 特性 | 树 | DAG |  
|------------|-------------|--------------|  
| 入度 | 根节点为 0 | 允许多个 0 入度节点 |  
| 边方向 | 父 → 子固定 | 任意有向边 |  
| 连通性 | 全连通 | 可存在孤立子图 |

### 2. 表达式 DAG 化（Python 实现）

```python
class DAGNode:
    def __init__(self, val, left=None, right=None):
        self.val = val    # 存储操作数/运算符
        self.left = left  # 左操作数
        self.right = right# 右操作数
        self.hash = hash((val, id(left), id(right))) # 唯一标识符

def build_expression_dag(expr: str) -> DAGNode:
    """
    输入示例："a+a*(b-c)+(b-c)*d"
    输出：合并后的DAG根节点
    关键边界处理：
    - 运算符优先级处理（需先构建低优先级运算符节点）
    - 公共子表达式识别（通过哈希值快速查找）
    """
```

### 3. 分层优化策略

**操作步骤**：

1. 词法分析：提取所有**基础操作数**（如 a,b,c,d）
2. 第一层构建：创建直接操作基础操作数的运算符节点（如 b-c）
3. 跨层合并：检查高层运算符的操作数是否可复用现有节点（如复用 b-c 节点）
4. 拓扑排序验证：确保无环性（Kahn 算法时间复杂度$O(V+E)$）

**优化效果对比**：  

| 表达式 | 普通 AST 节点数 | 优化后 DAG 节点数 |  
|------------------------|---------------|-----------------|  
| a+a*(b-c)+(b-c)*d | 11 | 7 |  
| x*(y+z)+y*(x+z) | 9 | 6 |

### 4. 408 真题实战

**题目**：对表达式`a+a*(b-c)+(b-c)*d`构建 DAG，求节点减少量  
**解析步骤**：

1. 基础操作数：a(×2), b, c, d
2. 第一层操作：
   - `op1: b - c`（创建新节点）
3. 第二层操作：
   - `op2: a * op1`
   - `op3: op1 * d`
4. 第三层操作：
   - `op4: a + op2`
   - `op5: op4 + op3`  
     **节点总数**：5 操作数 + 5 运算符 = 10 → 优化后为 7 个（减少 3 个）

---

## 总结区

1. **核心考点**：

   - DAG 节点数计算（操作数去重+运算符分层统计）
   - 拓扑排序在表达式求值顺序中的应用

2. **高频错误**：

   - 忽略运算符结合顺序导致层级划分错误
   - 未识别隐式公共子表达式（如矩阵运算中的重复计算）

3. **扩展思考**：

   - 如何将 DAG 优化思想应用于编译器中间代码生成？
   - 动态规划中状态转移方程的 DAG 表示与剪枝优化

4. **代码要点**：
   - 使用哈希值加速节点查重
   - 通过递归下降法实现运算符优先级处理

> **下阶段重点**：DAG 在拓扑排序中的应用（LeetCode 210 课程表 II）与三元式优化代码生成
