# 图的存储结构：邻接矩阵

## 摘要

本节系统讲解图的邻接矩阵存储方法，包含原理实现、应用场景与复杂度分析。通过无向图/有向图对比、带权图实现示例，阐明节点度计算与空间效率优化策略。最后给出 Python/C++代码模板与 LeetCode 对应习题。

> **算法分类标签**：图论/数据结构

---

## 主题

邻接矩阵的核心原理与工程实践要点，重点掌握：

1. 矩阵构建方法与空间特性
2. 节点度计算方法
3. 带权图存储实现
4. 稠密图场景下的适用性分析

> **重点难点**
>
> - 矩阵对称性的空间优化
> - 有向图入度/出度计算差异
> - 权值无穷大的工程表示方法

---

## 线索区

### 1. 邻接矩阵原理

**存储结构**：

- 二维数组`adj_matrix[n][n]`存储顶点间关系
- `adj_matrix[i][j] = 1`表示顶点 i 到 j 存在边（无权图）

**数学特性**：

- 无向图矩阵对称：$\forall i,j,\ adj\_matrix[i][j] = adj\_matrix[j][i]$
- 有向图非对称：边方向与矩阵下标严格对应

### 2. 节点度计算

| 图类型 | 计算方法                         | 公式表达                                                                                          |
| ------ | -------------------------------- | ------------------------------------------------------------------------------------------------- |
| 无向图 | 行/列非零元素个数                | $\deg(v_i) = \sum_{k=0}^{n-1} adj\_matrix[i][k]$                                                  |
| 有向图 | 出度：行非零数`<br>`入度：列非零数 | $out\_deg = \sum_{k=0}^{n-1} adj\_matrix[i][k]$`<br>`$in\_deg = \sum_{k=0}^{n-1} adj\_matrix[k][i]$ |

**现实类比**：社交网络关注关系

- 出度：你关注的人数
- 入度：关注你的人数

### 3. 带权图实现

```python
# Python带权图实现
INF = float('inf')
n = 5  # 顶点数

# 初始化邻接矩阵
adj_matrix = [[INF]*n for _ in range(n)]
for i in range(n):
    adj_matrix[i][i] = 0  # 对角线清零

# 添加边（带权值）
edges = [(0,1,2), (1,2,3), (2,3,5)]
for u, v, w in edges:
    adj_matrix[u][v] = w
    # 无向图需同时设置 adj_matrix[v][u] = w
```

```cpp
// C++带权图实现
#include <vector>
using namespace std;

const int INF = INT_MAX;
const int N = 100;

vector<vector<int>> createAdjMatrix() {
    vector<vector<int>> matrix(N, vector<int>(N, INF));
    for(int i=0; i<N; ++i)
        matrix[i][i] = 0;  // 处理自环边界
    return matrix;
}
```

### 4. 复杂度分析

**空间复杂度**：

- 基础实现：$O(n^2)$
- 优化策略：
  - 对称矩阵压缩存储（无向图） → $O(\frac{n(n-1)}{2})$
  - 稀疏矩阵采用邻接表更优

**时间效率**：

- 查边存在性：$O(1)$
- 遍历邻接点：$O(n)$

---

## 总结区

### 核心考点

1. 邻接矩阵的**空间特性**与**适用场景**
2. 有向图**入度/出度**计算的差异
3. 权值图中**特殊值**（无穷大）的工程实现

### 典型应用

- LeetCode 997. 找到小镇的法官（入度计算）
- LeetCode 743. 网络延迟时间（Dijkstra 算法基础）

### 优化方向

1. **对称压缩存储**：利用无向图的对称性减少存储量
2. **位运算优化**：用 bit 位表示无权图（空间降为$O(n^2/8)$）
3. **分块存储**：大图场景下的内存分页优化

> **下阶段重点**：对比邻接表实现，理解不同存储结构在 BFS/DFS 中的性能差异
