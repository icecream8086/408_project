# 折半查找

## 摘要  
**目的**：实现有序数据高效检索  
**方法**：基于有序顺序表的二分策略与判定树建模  
**结果**：时间复杂度优化至**O(log₂n)**，构造具有**n+1个失败节点**的平衡判定树  
**结论**：算法效率由判定树平衡性保证，适用于静态查找场景  

---

## 主题  
**核心内容**：有序数据二分策略的算法实现与树形结构建模  
**关键词**：  
- 有序顺序表  
- 判定树平衡性  
- 树高计算  
- 成功/失败节点比  

> 重点难点  
> - 判定树构造与完全二叉树的关系  
> - 树高计算中的向上取整规则  
> - **失败节点数 = 成功节点数 +1**的证明  

---

## 线索区  

### 算法实现流程  
1. **初始条件**  
   - 存储结构：有序顺序表（递增/递减）  
   - 指针定义：`low`（首元素）、`high`（末元素）  

2. **迭代步骤**  
   ```python  
   while low ≤ high:
       mid = (low + high) // 2  # 取中间位置
       if key == arr[mid]: return mid
       elif key < arr[mid]: high = mid -1  # 左半区
       else: low = mid +1  # 右半区
   return -1  # 查找失败
   ```  
   **关键操作**：每次迭代搜索范围减半  

3. **终止条件**  
   - 成功：`arr[mid] == key`  
   - 失败：`low > high`（搜索空间耗尽）  

---

### 判定树性质  
1. **结构特征**  
   - 平衡二叉排序树（左右子树高度差≤1）  
   - 叶子节点仅出现在最后两层  
   - 类比：组织结构类似公司层级，每层代表一次关键决策  

2. **数学表征**  
   - 树高公式：  
     \( h = \lceil \log_2(n+1) \rceil \)  
     *（n为表长，⌈⌉表示向上取整）*  
   - 节点数量：  
     - 成功节点数 = n  
     - 失败节点数 = n+1  

3. **查找路径**  
   - 成功查找：根到内部节点的路径  
   - 失败查找：根到叶子节点空指针的路径  

![判定树示例](https://via.placeholder.com/400x200?text=Balanced+Decision+Tree)  
*图示：7元素顺序表对应的判定树，3层结构含7成功节点与8失败节点*  

---

### 复杂度分析  
| 指标        | 表达式            | 对比次数上限 |
|-------------|-------------------|--------------|
| 成功查找    | **O(log₂n)**      | h次          |
| 失败查找    | **O(log₂n)**      | h次          |
| 顺序查找    | O(n)              | n次          |

**效率提升比**：  
当n=1024时，折半查找最多10次 vs 顺序查找1024次  

---

## 总结区  
1. **核心考点**  
   - 判定树构造过程绘图  
   - 树高计算（特别注意向上取整规则）  
   - 成功/失败节点数关系证明  

2. **典型题型**  
   - 给定序列绘制判定树  
   - 计算特定元素的最大查找次数  
   - 比较顺序查找与折半查找的适用场景  

3. **易错点**  
   - 误用链表实现折半查找（需随机访问特性）  
   - 混淆判定树与普通二叉排序树的平衡性差异  

> **现实映射**：类比图书馆目录检索系统，二分策略对应分区查找图书编号的过程，判定树结构类似图书分类架的层级结构。