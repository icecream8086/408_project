# 堆排序算法详解

## 摘要

**目的**：实现基于堆数据结构的排序  
**方法**：通过建堆操作构建大根堆/小根堆，循环执行堆顶元素交换与堆调整  
**结果**：时间复杂度**O(n log₂n)**，空间复杂度**O(1)**  
**结论**：适用于大规模数据的不稳定排序算法

---

## 主题

**核心方法**：完全二叉树顺序存储 + 下坠调整（heapify down）  
**关键词**：大根堆性质、分支节点调整、原地排序  
**问题提示**：

1. 如何保证建堆过程的线性时间复杂度？
2. 下坠操作中父节点与子节点的比较顺序？

> 重点难点
>
> - **堆特性维护**：非终端节点的持续调整机制
> - **稳定性缺陷**：元素交换导致相同值元素相对位置变化
> - **时间复杂度证明**：建堆 Σ(lg k)的收敛性分析

---

## 线索区

### 知识点 1：堆的数学定义

- **完全二叉树特性**：
  - 节点索引关系（从 1 开始计数）：
    $$
    \begin{cases}
    \text{左孩子} & 2i \\
    \text{右孩子} & 2i+1 \\
    \text{父节点} & \lfloor i/2 \rfloor
    \end{cases}
    $$
  - 树高计算公式：$h = \lfloor \log_2 n \rfloor + 1$
- **大根堆判定式**：
  $$
  \forall i \in [1, \lfloor n/2 \rfloor],\ A[i] \geq \max(A[2i], A[2i+1])
  $$

### 知识点 2：建堆过程解析

**操作流程**：

1. 从末位分支节点（\( i = \lfloor n/2 \rfloor \)）开始逆向遍历
2. 对每个节点执行下坠调整：

   ```python
   def heapify(arr, n, i):
       largest = i
       l = 2 * i
       r = 2 * i + 1
       if l <= n and arr[l] > arr[largest]:
           largest = l
       if r <= n and arr[r] > arr[largest]:
           largest = r
       if largest != i:
           arr[i], arr[largest] = arr[largest], arr[i]
           heapify(arr, n, largest)
   ```

   **时间复杂度证明**：

- 每个节点调整次数与其高度成正比
- 建堆总时间：  
  $$T(n) = \sum_{h=0}^{\log_2 n} \frac{n}{2^{h+1}} \cdot h = O(n)$$

### 知识点 3：排序阶段优化

**关键操作**：

1. 交换堆顶与堆底元素（最大值归位）
2. 堆大小减 1 后重新调整  
   **操作示意图**：

```txt
初始堆：[9,7,5,2,3]
第1趟：交换9↔3 → 调整 → [7,3,5,2|9]
第2趟：交换7↔2 → 调整 → [5,3,2|7,9]
```

---

## 总结区

**核心考点**：

1. 堆的父子节点索引计算（应用题）
2. 建堆时间复杂度推导（证明题）
3. 堆排序不稳定性示例（简答题）

**重点辨析**：

- 堆排序与直接选择排序的本质区别：利用堆结构减少比较次数
- 大根堆与小根堆在算法中的对称性应用

**复杂度对比**：  

| 算法 | 平均时间复杂度 | 空间复杂度 | 稳定性 |
|----------|----------------|------------|--------|
| 堆排序 | **O(n logn)** | **O(1)** | × |
| 快速排序 | O(n logn) | O(logn) | × |
| 归并排序 | O(n logn) | O(n) | √ |

请确认是否需要调整内容细节或补充特定方向的扩展说明。
