# 基数排序

## 摘要

- **目的**：实现非比较型高效排序
- **方法**：多轮关键字位分配与收集
- **结果**：时间复杂度 O(D\*(N+R))，稳定排序
- **结论**：适用于多关键字、大基数场景

---

## 主题

通过低位到高位的多轮排序实现全局有序  
**关键词**：基数 R、分配队列、稳定排序  
**核心问题**：如何确定最优基数？为何收集顺序影响稳定性？

> 重点难点
>
> - 基数选择与时间复杂度权衡
> - 高位优先(MSD)与低位优先(LSD)实现差异
> - 空间复杂度与元素分布的关联

---

## 线索区

### 基本定义

- **非比较排序**：通过元素位值分布实现排序
- **基数(Radix)**：每个数位的可能取值数量
  - 十进制数：R=10（每位 0-9）
  - 二进制数：R=2（每位 0-1）

### 算法流程

**LSD 实现步骤**（最低位优先）：

1. **分配阶段**
   - 创建 R 个空队列（桶）
   - 按当前位值将元素放入对应队列

   ```python
   for d in 0 to D-1:
       buckets = [[] for _ in range(R)]
       for num in nums:
           digit = (num // 10^d) % 10
           buckets[digit].append(num)
   ```

2. **收集阶段**
   - 按队列编号升序收集元素
   - 保持相同位值的原始顺序（保证稳定性）

### 时间复杂度模型

- **公式**：

  $$
  T(n) = D × (N + R)
  $$
  
  - **D**：最大数位位数（关键路径长度）
  - **R**：基数大小（空间开销因子）
  - **N**：元素数量（时间主导项）

### 关键参数优化

- **基数选择**：
  - **R=10**：直观但空间利用率低
  - **R=2^k**：可通过位运算加速（例：R=16 时，4 位二进制截取）
- **位权顺序**：
  - **LSD**：必须稳定排序
  - **MSD**：可递归处理但复杂度波动

### 工程实践案例

- **IPv4 地址排序**：
  - D=4（每个字节为 1 段）
  - R=256（每字节取值范围）
  - 时间复杂度：4×(N+256) → O(N)
- **词典序排序**：
  - 将字符串视为多关键字组合
  - 空字符处理决定排序稳定性

---

## 总结区

### 核心考点

- **时间复杂度计算**：区分 D、R、N 的贡献比例
- **稳定性证明**：基于收集阶段的队列合并方式
- **基数选择实验**：推导最优 R 值的数学方法

### 典型错误

- 未对齐数位导致排序失效（前导零处理）
- 混淆 MSD/LSD 的收集顺序要求
- 忽略空间复杂度对大规模数据的影响

### 应用场景判断矩阵

| 数据特征          | 适合基数排序 | 不适合原因         |
| ----------------- | ------------ | ------------------ |
| 固定长度字符串    | ✓            | 天然多关键字结构   |
| 浮点数数组        | ✗            | 小数位处理复杂度高 |
| 10^6 个 32 位整数 | ✓            | R=65536 效率仍可观 |
| 稀疏分布的大整数  | ✗            | 空桶过多浪费空间   |

---

当前结构已按学术笔记标准优化，是否需要针对特定考试题型添加练习题解析？
