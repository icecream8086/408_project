# 置换选择排序与外部排序优化

## 摘要

通过动态替换内存记录生成超长归并段，置换选择排序突破传统外部排序的内存限制，将归并段数量减少**33%-50%**，显著降低磁盘 I/O 次数。核心原理基于 minimax 值监控与置换策略，实现**归并段长度 > 内存容量**。

## 主题

**三阶段优化框架**：归并段生成 → 置换选择 → 多路归并  
**关键技术指标**：

- 归并段数量 R ∝ 1/(平均段长)
- 磁盘 I/O 次数 = 2 × R × 块数  
  **典型问题场景**：内存容量 3 时处理 24 记录数据集

> 重点难点
>
> - minimax 值的动态更新机制
> - 归并段终止条件判定
> - 与传统方法的性能对比

## 线索区

### 1. 归并段生成原理

**定义**：归并段(run)是满足$R_i ≤ R_j (i < j)$的有序记录序列  
**核心公式**：  
$$\text{最优归并段数} = \left\lceil \frac{N}{M \times k} \right\rceil$$

- $N$: 总记录数
- $M$: 内存容量
- $k$: 倍增系数（传统方法$k=1$，置换选择$k>1$）

**应用场景**：  
当处理**10GB 日志文件**（内存仅 1GB）时，传统方法产生 10 个归并段，置换选择可降至 4-6 个

---

### 2. 置换选择算法流程

**硬件架构**：

```plaintext
输入缓冲区 → 内存工作区（堆结构） → 输出缓冲区 → FO文件
```

**五步执行法**：

1. 初始化：载入 M 个记录构建最小堆
2. 输出堆顶记录到 FO
3. 读入新记录：
   - if 新记录 ≥ 当前 minimax → 替换堆顶，堆化
   - else → 暂存至堆底
4. 更新 minimax = 最后输出值
5. 终止条件：当堆空时结束当前归并段

**示例演示**（M=3）：

```plaintext
初始堆: [15, 20, 12] → 输出12
输入18 → 12 ≤18 → 替换为18 → 堆[15,20,18]
输出15 → 输入9 <15 → 暂存 → 堆[18,20]
...
生成归并段：12,15,18,20,9（需二次归并）
```

---

### 3. 性能优化分析

**对比实验**（N=24, M=3）：  

| 方法 | 归并段数 | 理论 I/O 次数 |
|-----------------|----------|-------------|
| 传统方法 | 8 | 16× 块数 |
| 置换选择 | 3 | 6× 块数 |
| **优化率** | **62.5%**| **62.5%** |

**瓶颈突破点**：

- 允许后续记录小于当前 minimax（暂存机制）
- 堆结构维护时间复杂度：$O(\log M)$

---

## 总结区

**核心考点**：

1. 置换选择相比传统方法的改进原理（公式推导）
2. 堆维护操作对算法效率的影响（时间复杂度分析）
3. 归并段终止条件的代码实现（状态机转换）

**典型题型**：

- 给定输入序列和 M 值，计算生成归并段数量
- 分析置换选择在不同数据分布下的性能差异
- 设计改进算法处理重复键值场景

**实验验证建议**：

1. 使用 Python heapq 模块实现核心算法
2. 通过`sys.getsizeof()`监控内存使用
3. 用 CSV 文件模拟磁盘块读写过程
