# 归并排序

## 摘要

归并排序采用分治策略，通过递归分解序列（\(O(\log n)\)层）与有序合并（\(O(n)\)/层）实现排序，具有**稳定**、**\(O(n \log n)\)时间复杂度**特性，适用于海量数据排序场景。

## 主题

分治法框架下的递归排序实现，核心为合并操作与递归控制，关键技术特征包含：

- 二路归并的指针比较机制
- 递归树深度与时间复杂度的定量关系
- 空间-时间权衡策略

> 重点难点
>
> - **递归终止条件**的边界控制
> - **辅助空间优化**方法（如链表实现）
> - **外部排序**中的多路归并实现

---

## 线索区

### 1. 归并操作核心原理

**定义**：将两个有序子序列合并为整体有序序列  
**数学表达**：  
设子序列为 $A[p..q]$ 与 $A[q+1..r]$，合并后 $A[p..r]$ 有序  

**算法步骤**：

1. 创建临时数组 $B[p..r]$
2. 初始化指针 $i=p$, $j=q+1$, $k=0$
3. 循环比较 $A[i]$ 与 $A[j]$，较小值存入 $B[k]$
4. 将剩余元素拷贝至 $B$
5. 将 $B$ 复制回 $A[p..r]$

**技术图示**：

```txt
左子序列 [3,27,38]   右子序列 [9,10,43]
          ↓ 合并操作
      [3,9,10,27,38,43]
```

---

### 2. 递归控制结构

**递推关系式**：  
$$
T(n) = 2T\left(\frac{n}{2}\right) + O(n)
$$

**实现要点**：

- 递归深度：$\lceil \log_2 n \rceil$（二叉树高度类比）
- 空间消耗：**$O(n)$**（临时数组主导）+ **$O(\log n)$**（栈空间）
**伪代码表示**：

```python
def merge_sort(A, p, r):
    if p < r:
        q = (p + r) // 2
        merge_sort(A, p, q)
        merge_sort(A, q+1, r)
        merge(A, p, q, r)
```

---

### 3. 复杂度分析

**时间复杂度**：

- 最优/最差/平均：**$\Theta(n \log n)$**
- 推导过程：  
  每层递归需 $O(n)$ 合并操作，总层数 $\log_2 n$ → $O(n \log n)$

**空间复杂度**：

- 基本实现：**$O(n)$**（临时数组）
- 优化方案：
  - 链表结构 → $O(1)$ 原地合并
  - 手摇算法 → 空间优化但增加时间开销

---

### 4. 稳定性与应用场景

**稳定性证明**：  
当 $A[i] == A[j]$ 时优先取左子序列元素，保持原始相对顺序

**典型应用**：  

| 场景类型 | 实现特点 | 案例 |
|---------|---------|-----|
| 内部排序 | 二路归并 | 内存数据排序 |
| 外部排序 | 多路归并 | 海量日志文件处理 |
| 并行计算 | MapReduce 分阶段合并 | 分布式系统排序 |

---

## 总结区

### 知识图谱

```mermaid
graph LR
A[分治法] --> B(递归分解)
A --> C(有序合并)
B --> D[时间复杂度O(n log n)]
C --> E[空间复杂度O(n)]
E --> F{优化方向}
F --> G[原地归并]
F --> H[多路归并]
```

### 考点映射

1. **复杂度推导**：主定理法求解递推方程
2. **稳定性对比**：与快速排序、堆排序的差异
3. **手写算法**：合并过程的具体实现
4. **外部排序**：归并路数与缓冲区大小的关系

### 记忆锚点

- **递归树叶子数** = n（反映基础 case 数量）
- **合并操作次数** = n-1（最坏比较次数）
- **空间开销峰值** = n（临时数组满负荷时）
