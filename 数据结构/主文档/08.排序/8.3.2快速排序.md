# 快速排序算法

## 摘要

快速排序通过递归划分实现高效排序：

1. **核心机制**：基准元素分割数组为有序子区间
2. **时间复杂度**：最优$O(n \log n)$，最差$O(n^2)$
3. **优化方向**：基准选择策略优化提升平均性能

---

## 主题

> **分治策略在排序中的典型应用**

- 核心方法：基准划分 → 递归处理子区间
- 关键技术：双指针扫描法、递归深度控制
- 关键参数：**比较次数=14 次**（示例数据）

> 重点难点
>
> - 双指针移动的边界条件判定
> - 递归树深度与时间复杂度关系
> - "一趟排序"的准确定义（408 考点）

---

## 线索区

### 1. 算法原理框架

**定义**：通过基准元素将序列$S$划分为$S_1$（元素 ≤ 基准）和$S_2$（元素 ≥ 基准）  
**数学表达**：

$$
\text{QuickSort}(S) =
\begin{cases}
\emptyset & \text{if } |S| \leq 1 \\
\text{QuickSort}(S_1) \cup \{pivot\} \cup \text{QuickSort}(S_2) & \text{otherwise}
\end{cases}
$$

**特性**：

- 不稳定性：相同元素可能改变相对位置
- 原地排序：空间复杂度**$O(\log n)$**（最优递归栈深度）

### 2. 双指针划分过程

**实现步骤**：

1. 初始化：`low=start`, `high=end`
2. 基准选择：示例取首元素 49
3. 扫描循环：
   - **右指针**先移动：`while high>low && a[high]≥pivot → high--`
   - **左指针**后移动：`while low<high && a[low]<pivot → low++`
4. 终止条件：`low==high`时确定基准最终位置

**关键约束**：

- 必须右指针先扫描（保证相遇点值 ≤ 基准）
- 元素相等时的处理影响算法稳定性

### 3. 时间复杂度分析

**递推关系**：

$$
T(n) = T(k) + T(n-k-1) + O(n)
$$

其中$k$为划分后子区间大小

**典型场景**：  

| 情况 | 递归树形态 | 时间复杂度 |  
|------|------------|------------|  
| 最优 | 完全平衡 | **$O(n \log n)$** |  
| 最差 | 单侧延伸 | **$O(n^2)$** |  
| 平均 | 近似平衡 | $O(n \log n)$ |

**空间复杂度**：

- 最差**$O(n)$**（完全不平衡递归）
- 最优**$O(\log n)$**（完全平衡递归）

### 4. 优化技术对比

| 方法     | 实现方式             | 效果                      |
| -------- | -------------------- | ------------------------- |
| 三数取中 | 取首、中、尾的中位数 | 降低最差概率至 12.5%      |
| 随机化   | 随机选择基准         | 数学期望$O(n \log n)$     |
| 尾递归   | 手动维护递归栈       | 空间复杂度降至$O(\log n)$ |

---

## 总结区

**核心考点**：

1. 手写划分过程代码（注意指针移动顺序）
2. 递归树高度与时间复杂度的关系证明
3. **408 特殊定义**："一趟排序"指所有子表都完成一次划分

**常见误区**：

- 认为快速排序在任何情况下都比归并排序快（忽略最坏情况）
- 混淆空间复杂度的组成（递归栈 vs 辅助数组）

**关联知识**：

- 分治策略：与归并排序对比（时间/空间/稳定性）
- 递归复杂度：主定理的应用场景

> 通过将划分过程类比快递分拣（按重量分两堆再分别处理），可直观理解分治思想。基准选择相当于选择分拣标准，递归深度反映分拣效率。
